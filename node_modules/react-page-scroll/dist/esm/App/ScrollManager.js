import SectionScrollHandler from './SectionScrollHandler';
class ScrollStack {
    constructor(scrollHandlerHash) {
        this.stack = [];
        if (scrollHandlerHash) {
            this.stack.push(scrollHandlerHash);
        }
    }
    push(scrollHandlerHash) {
        this.stack.push(scrollHandlerHash);
    }
    pop() {
        return this.stack.pop();
    }
    item(i) {
        return Object.assign({}, this.stack[i]);
    }
    get length() {
        return this.stack.length;
    }
    get current() {
        return this.stack[this.length - 1];
    }
    get previous() {
        return this.stack[this.length - 2];
    }
}
class ScrollControl {
    constructor(scrollManager) {
        this.scrollManager = scrollManager;
    }
    scrollTo(target) {
        this.scrollManager.activeScrollHandler.scrollTo(target);
    }
    scrollToNext() {
        const { currentChildIndex, childs } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;
        const nextTargetIndex = Math.min(currentChildIndex + 1, childs.length - 1);
        this.scrollTo(nextTargetIndex);
    }
    scrollToPrevious() {
        const { currentChildIndex } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;
        const nextTargetIndex = Math.max(currentChildIndex - 1, 0);
        this.scrollTo(nextTargetIndex);
    }
}
export class ScrollManager {
    constructor() {
        this.scrollStack = new ScrollStack();
        this.scrollHandlersMap = {};
        this.scrollControl = new ScrollControl(this);
    }
    getScrollMove(scrollState) {
        const { XDirection, YDirection } = scrollState;
        if (YDirection !== 'stationary') {
            return YDirection;
        }
        if (XDirection !== 'stationary') {
            return XDirection;
        }
        return null;
    }
    hasReachedEndOfDocument(currentChildIndex, childs, scrollState) {
        const scrollMove = this.getScrollMove(scrollState) || '';
        const reachedEndOfDocument = ['down', 'left'].includes(scrollMove) && currentChildIndex === childs.length - 1;
        const reachedStartOfDocument = ['up', 'right'].includes(scrollMove) && !currentChildIndex;
        const reachedDocumentStartOrEnd = reachedEndOfDocument || reachedStartOfDocument;
        if (this.scrollStack.previous) {
            const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;
            const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;
            return currentScrollDirection === parentScrollDirection && reachedDocumentStartOrEnd;
        }
        return reachedDocumentStartOrEnd;
    }
    shouldParentResumeScrolling(scrollState) {
        const scrollMove = this.getScrollMove(scrollState) || '';
        const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;
        const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;
        if (currentScrollDirection !== parentScrollDirection) {
            if (parentScrollDirection === 'horizontal' && ['left', 'right'].includes(scrollMove)) {
                return true;
            }
            if (parentScrollDirection === 'vertical' && ['up', 'down'].includes(scrollMove)) {
                return true;
            }
        }
        return false;
    }
    transferControlToChild(childNodeHash) {
        var _a;
        const currentScrollHandlerHash = (_a = this.scrollStack.current) === null || _a === void 0 ? void 0 : _a.hash;
        const currentScrollHandler = this.scrollHandlersMap[currentScrollHandlerHash];
        const { currentChildIndex, childs, scrollState } = currentScrollHandler.UIScrollStateCopy;
        currentScrollHandler.disable();
        this.scrollStack.current.scrollState = {
            reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),
            direction: this.getScrollMove(scrollState),
        };
        const childScrollHandler = this.scrollHandlersMap[childNodeHash];
        this.initializeScrollHandler(childScrollHandler);
        this.scrollStack.push({
            hash: childNodeHash,
            scrollState: { reachedEndOfDocument: false, direction: null },
        });
        return true;
    }
    transferControlToParent(scrollState) {
        var _a;
        for (let i = this.scrollStack.length - 2; i >= 0; i--) {
            const { scrollState: { reachedEndOfDocument, direction }, hash, } = this.scrollStack.item(i);
            const nextScrollDirection = this.getScrollMove(scrollState);
            if (!(reachedEndOfDocument && direction === nextScrollDirection)) {
                let currentHash = '';
                for (let j = this.scrollStack.length - 1; j > i; j--) {
                    currentHash = ((_a = this.scrollStack.pop()) === null || _a === void 0 ? void 0 : _a.hash) || '';
                    this.scrollHandlersMap[currentHash].disable();
                }
                const { onScrollCommandCede, pagesContainer, currentChildIndex } = this.scrollHandlersMap[currentHash].UIScrollStateCopy;
                if (pagesContainer.parentElement && onScrollCommandCede) {
                    onScrollCommandCede({
                        lastChildIndex: currentChildIndex,
                    });
                }
                this.initializeScrollHandler(this.scrollHandlersMap[hash]);
                return true;
            }
        }
        return false; //this was added
    }
    initializeScrollHandler(sectionScrollHandler) {
        sectionScrollHandler.init(this.scrollControl);
    }
    get activeScrollHandler() {
        return this.scrollHandlersMap[this.scrollStack.current.hash];
    }
    shouldCedeControlToChld({ childs, currentChildIndex }) {
        const currentNodeHash = childs[currentChildIndex].dataset.reactScroller;
        if (currentNodeHash) {
            return this.transferControlToChild(currentNodeHash);
        }
        return false;
    }
    shouldCedeControlToParent({ childs, currentChildIndex, scrollState }) {
        if (this.shouldParentResumeScrolling(scrollState) ||
            this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState)) {
            return this.transferControlToParent(scrollState);
        }
        return false;
    }
    subscribe(container, scrollUIState) {
        var _a;
        const sectionScrollHandler = new SectionScrollHandler(container, scrollUIState, this);
        const { currentChildIndex, childs, scrollState, isRoot } = scrollUIState;
        if (isRoot) {
            this.scrollHandlersMap.root = sectionScrollHandler;
            this.scrollStack.push({
                hash: 'root',
                scrollState: {
                    reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),
                    direction: this.getScrollMove(scrollState),
                },
            });
            this.initializeScrollHandler(sectionScrollHandler);
        }
        else {
            const hash = 'nested-' + (Object.keys(this.scrollHandlersMap).length + 1);
            this.scrollHandlersMap[hash] = sectionScrollHandler;
            ((_a = sectionScrollHandler.container) === null || _a === void 0 ? void 0 : _a.parentElement).setAttribute('data-react-scroller', hash);
        }
        return sectionScrollHandler;
    }
}
export const scrollManager = new ScrollManager();
