{"ast":null,"code":"import SectionScrollHandler from './SectionScrollHandler';\nclass ScrollStack {\n  constructor(scrollHandlerHash) {\n    this.stack = [];\n    if (scrollHandlerHash) {\n      this.stack.push(scrollHandlerHash);\n    }\n  }\n  push(scrollHandlerHash) {\n    this.stack.push(scrollHandlerHash);\n  }\n  pop() {\n    return this.stack.pop();\n  }\n  item(i) {\n    return Object.assign({}, this.stack[i]);\n  }\n  get length() {\n    return this.stack.length;\n  }\n  get current() {\n    return this.stack[this.length - 1];\n  }\n  get previous() {\n    return this.stack[this.length - 2];\n  }\n}\nclass ScrollControl {\n  constructor(scrollManager) {\n    this.scrollManager = scrollManager;\n  }\n  scrollTo(target) {\n    this.scrollManager.activeScrollHandler.scrollTo(target);\n  }\n  scrollToNext() {\n    const {\n      currentChildIndex,\n      childs\n    } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n    const nextTargetIndex = Math.min(currentChildIndex + 1, childs.length - 1);\n    this.scrollTo(nextTargetIndex);\n  }\n  scrollToPrevious() {\n    const {\n      currentChildIndex\n    } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n    const nextTargetIndex = Math.max(currentChildIndex - 1, 0);\n    this.scrollTo(nextTargetIndex);\n  }\n}\nexport class ScrollManager {\n  constructor() {\n    this.scrollStack = new ScrollStack();\n    this.scrollHandlersMap = {};\n    this.scrollControl = new ScrollControl(this);\n  }\n  getScrollMove(scrollState) {\n    const {\n      XDirection,\n      YDirection\n    } = scrollState;\n    if (YDirection !== 'stationary') {\n      return YDirection;\n    }\n    if (XDirection !== 'stationary') {\n      return XDirection;\n    }\n    return null;\n  }\n  hasReachedEndOfDocument(currentChildIndex, childs, scrollState) {\n    const scrollMove = this.getScrollMove(scrollState) || '';\n    const reachedEndOfDocument = ['down', 'left'].includes(scrollMove) && currentChildIndex === childs.length - 1;\n    const reachedStartOfDocument = ['up', 'right'].includes(scrollMove) && !currentChildIndex;\n    const reachedDocumentStartOrEnd = reachedEndOfDocument || reachedStartOfDocument;\n    if (this.scrollStack.previous) {\n      const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n      const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n      return currentScrollDirection === parentScrollDirection && reachedDocumentStartOrEnd;\n    }\n    return reachedDocumentStartOrEnd;\n  }\n  shouldParentResumeScrolling(scrollState) {\n    const scrollMove = this.getScrollMove(scrollState) || '';\n    const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n    const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n    if (currentScrollDirection !== parentScrollDirection) {\n      if (parentScrollDirection === 'horizontal' && ['left', 'right'].includes(scrollMove)) {\n        return true;\n      }\n      if (parentScrollDirection === 'vertical' && ['up', 'down'].includes(scrollMove)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  transferControlToChild(childNodeHash) {\n    var _a;\n    const currentScrollHandlerHash = (_a = this.scrollStack.current) === null || _a === void 0 ? void 0 : _a.hash;\n    const currentScrollHandler = this.scrollHandlersMap[currentScrollHandlerHash];\n    const {\n      currentChildIndex,\n      childs,\n      scrollState\n    } = currentScrollHandler.UIScrollStateCopy;\n    currentScrollHandler.disable();\n    this.scrollStack.current.scrollState = {\n      reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n      direction: this.getScrollMove(scrollState)\n    };\n    const childScrollHandler = this.scrollHandlersMap[childNodeHash];\n    this.initializeScrollHandler(childScrollHandler);\n    this.scrollStack.push({\n      hash: childNodeHash,\n      scrollState: {\n        reachedEndOfDocument: false,\n        direction: null\n      }\n    });\n    return true;\n  }\n  transferControlToParent(scrollState) {\n    var _a;\n    for (let i = this.scrollStack.length - 2; i >= 0; i--) {\n      const {\n        scrollState: {\n          reachedEndOfDocument,\n          direction\n        },\n        hash\n      } = this.scrollStack.item(i);\n      const nextScrollDirection = this.getScrollMove(scrollState);\n      if (!(reachedEndOfDocument && direction === nextScrollDirection)) {\n        let currentHash = '';\n        for (let j = this.scrollStack.length - 1; j > i; j--) {\n          currentHash = ((_a = this.scrollStack.pop()) === null || _a === void 0 ? void 0 : _a.hash) || '';\n          this.scrollHandlersMap[currentHash].disable();\n        }\n        const {\n          onScrollCommandCede,\n          pagesContainer,\n          currentChildIndex\n        } = this.scrollHandlersMap[currentHash].UIScrollStateCopy;\n        if (pagesContainer.parentElement && onScrollCommandCede) {\n          onScrollCommandCede({\n            lastChildIndex: currentChildIndex\n          });\n        }\n        this.initializeScrollHandler(this.scrollHandlersMap[hash]);\n        return true;\n      }\n    }\n    return false; //this was added\n  }\n\n  initializeScrollHandler(sectionScrollHandler) {\n    sectionScrollHandler.init(this.scrollControl);\n  }\n  get activeScrollHandler() {\n    return this.scrollHandlersMap[this.scrollStack.current.hash];\n  }\n  shouldCedeControlToChld({\n    childs,\n    currentChildIndex\n  }) {\n    const currentNodeHash = childs[currentChildIndex].dataset.reactScroller;\n    if (currentNodeHash) {\n      return this.transferControlToChild(currentNodeHash);\n    }\n    return false;\n  }\n  shouldCedeControlToParent({\n    childs,\n    currentChildIndex,\n    scrollState\n  }) {\n    if (this.shouldParentResumeScrolling(scrollState) || this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState)) {\n      return this.transferControlToParent(scrollState);\n    }\n    return false;\n  }\n  subscribe(container, scrollUIState) {\n    var _a;\n    const sectionScrollHandler = new SectionScrollHandler(container, scrollUIState, this);\n    const {\n      currentChildIndex,\n      childs,\n      scrollState,\n      isRoot\n    } = scrollUIState;\n    if (isRoot) {\n      this.scrollHandlersMap.root = sectionScrollHandler;\n      this.scrollStack.push({\n        hash: 'root',\n        scrollState: {\n          reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n          direction: this.getScrollMove(scrollState)\n        }\n      });\n      this.initializeScrollHandler(sectionScrollHandler);\n    } else {\n      const hash = 'nested-' + (Object.keys(this.scrollHandlersMap).length + 1);\n      this.scrollHandlersMap[hash] = sectionScrollHandler;\n      ((_a = sectionScrollHandler.container) === null || _a === void 0 ? void 0 : _a.parentElement).setAttribute('data-react-scroller', hash);\n    }\n    return sectionScrollHandler;\n  }\n}\nexport const scrollManager = new ScrollManager();","map":{"version":3,"names":["SectionScrollHandler","ScrollStack","constructor","scrollHandlerHash","stack","push","pop","item","i","Object","assign","length","current","previous","ScrollControl","scrollManager","scrollTo","target","activeScrollHandler","scrollToNext","currentChildIndex","childs","UIScrollStateCopy","nextTargetIndex","Math","min","scrollToPrevious","max","ScrollManager","scrollStack","scrollHandlersMap","scrollControl","getScrollMove","scrollState","XDirection","YDirection","hasReachedEndOfDocument","scrollMove","reachedEndOfDocument","includes","reachedStartOfDocument","reachedDocumentStartOrEnd","currentScrollDirection","hash","direction","parentScrollDirection","shouldParentResumeScrolling","transferControlToChild","childNodeHash","_a","currentScrollHandlerHash","currentScrollHandler","disable","childScrollHandler","initializeScrollHandler","transferControlToParent","nextScrollDirection","currentHash","j","onScrollCommandCede","pagesContainer","parentElement","lastChildIndex","sectionScrollHandler","init","shouldCedeControlToChld","currentNodeHash","dataset","reactScroller","shouldCedeControlToParent","subscribe","container","scrollUIState","isRoot","root","keys","setAttribute"],"sources":["/Users/trungtran/Documents/GitHub/portfolio/node_modules/react-page-scroll/dist/esm/App/ScrollManager.js"],"sourcesContent":["import SectionScrollHandler from './SectionScrollHandler';\nclass ScrollStack {\n    constructor(scrollHandlerHash) {\n        this.stack = [];\n        if (scrollHandlerHash) {\n            this.stack.push(scrollHandlerHash);\n        }\n    }\n    push(scrollHandlerHash) {\n        this.stack.push(scrollHandlerHash);\n    }\n    pop() {\n        return this.stack.pop();\n    }\n    item(i) {\n        return Object.assign({}, this.stack[i]);\n    }\n    get length() {\n        return this.stack.length;\n    }\n    get current() {\n        return this.stack[this.length - 1];\n    }\n    get previous() {\n        return this.stack[this.length - 2];\n    }\n}\nclass ScrollControl {\n    constructor(scrollManager) {\n        this.scrollManager = scrollManager;\n    }\n    scrollTo(target) {\n        this.scrollManager.activeScrollHandler.scrollTo(target);\n    }\n    scrollToNext() {\n        const { currentChildIndex, childs } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n        const nextTargetIndex = Math.min(currentChildIndex + 1, childs.length - 1);\n        this.scrollTo(nextTargetIndex);\n    }\n    scrollToPrevious() {\n        const { currentChildIndex } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n        const nextTargetIndex = Math.max(currentChildIndex - 1, 0);\n        this.scrollTo(nextTargetIndex);\n    }\n}\nexport class ScrollManager {\n    constructor() {\n        this.scrollStack = new ScrollStack();\n        this.scrollHandlersMap = {};\n        this.scrollControl = new ScrollControl(this);\n    }\n    getScrollMove(scrollState) {\n        const { XDirection, YDirection } = scrollState;\n        if (YDirection !== 'stationary') {\n            return YDirection;\n        }\n        if (XDirection !== 'stationary') {\n            return XDirection;\n        }\n        return null;\n    }\n    hasReachedEndOfDocument(currentChildIndex, childs, scrollState) {\n        const scrollMove = this.getScrollMove(scrollState) || '';\n        const reachedEndOfDocument = ['down', 'left'].includes(scrollMove) && currentChildIndex === childs.length - 1;\n        const reachedStartOfDocument = ['up', 'right'].includes(scrollMove) && !currentChildIndex;\n        const reachedDocumentStartOrEnd = reachedEndOfDocument || reachedStartOfDocument;\n        if (this.scrollStack.previous) {\n            const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n            const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n            return currentScrollDirection === parentScrollDirection && reachedDocumentStartOrEnd;\n        }\n        return reachedDocumentStartOrEnd;\n    }\n    shouldParentResumeScrolling(scrollState) {\n        const scrollMove = this.getScrollMove(scrollState) || '';\n        const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n        const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n        if (currentScrollDirection !== parentScrollDirection) {\n            if (parentScrollDirection === 'horizontal' && ['left', 'right'].includes(scrollMove)) {\n                return true;\n            }\n            if (parentScrollDirection === 'vertical' && ['up', 'down'].includes(scrollMove)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    transferControlToChild(childNodeHash) {\n        var _a;\n        const currentScrollHandlerHash = (_a = this.scrollStack.current) === null || _a === void 0 ? void 0 : _a.hash;\n        const currentScrollHandler = this.scrollHandlersMap[currentScrollHandlerHash];\n        const { currentChildIndex, childs, scrollState } = currentScrollHandler.UIScrollStateCopy;\n        currentScrollHandler.disable();\n        this.scrollStack.current.scrollState = {\n            reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n            direction: this.getScrollMove(scrollState),\n        };\n        const childScrollHandler = this.scrollHandlersMap[childNodeHash];\n        this.initializeScrollHandler(childScrollHandler);\n        this.scrollStack.push({\n            hash: childNodeHash,\n            scrollState: { reachedEndOfDocument: false, direction: null },\n        });\n        return true;\n    }\n    transferControlToParent(scrollState) {\n        var _a;\n        for (let i = this.scrollStack.length - 2; i >= 0; i--) {\n            const { scrollState: { reachedEndOfDocument, direction }, hash, } = this.scrollStack.item(i);\n            const nextScrollDirection = this.getScrollMove(scrollState);\n            if (!(reachedEndOfDocument && direction === nextScrollDirection)) {\n                let currentHash = '';\n                for (let j = this.scrollStack.length - 1; j > i; j--) {\n                    currentHash = ((_a = this.scrollStack.pop()) === null || _a === void 0 ? void 0 : _a.hash) || '';\n                    this.scrollHandlersMap[currentHash].disable();\n                }\n                const { onScrollCommandCede, pagesContainer, currentChildIndex } = this.scrollHandlersMap[currentHash].UIScrollStateCopy;\n                if (pagesContainer.parentElement && onScrollCommandCede) {\n                    onScrollCommandCede({\n                        lastChildIndex: currentChildIndex,\n                    });\n                }\n                this.initializeScrollHandler(this.scrollHandlersMap[hash]);\n                return true;\n            }\n        }\n        return false; //this was added\n    }\n    initializeScrollHandler(sectionScrollHandler) {\n        sectionScrollHandler.init(this.scrollControl);\n    }\n    get activeScrollHandler() {\n        return this.scrollHandlersMap[this.scrollStack.current.hash];\n    }\n    shouldCedeControlToChld({ childs, currentChildIndex }) {\n        const currentNodeHash = childs[currentChildIndex].dataset.reactScroller;\n        if (currentNodeHash) {\n            return this.transferControlToChild(currentNodeHash);\n        }\n        return false;\n    }\n    shouldCedeControlToParent({ childs, currentChildIndex, scrollState }) {\n        if (this.shouldParentResumeScrolling(scrollState) ||\n            this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState)) {\n            return this.transferControlToParent(scrollState);\n        }\n        return false;\n    }\n    subscribe(container, scrollUIState) {\n        var _a;\n        const sectionScrollHandler = new SectionScrollHandler(container, scrollUIState, this);\n        const { currentChildIndex, childs, scrollState, isRoot } = scrollUIState;\n        if (isRoot) {\n            this.scrollHandlersMap.root = sectionScrollHandler;\n            this.scrollStack.push({\n                hash: 'root',\n                scrollState: {\n                    reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n                    direction: this.getScrollMove(scrollState),\n                },\n            });\n            this.initializeScrollHandler(sectionScrollHandler);\n        }\n        else {\n            const hash = 'nested-' + (Object.keys(this.scrollHandlersMap).length + 1);\n            this.scrollHandlersMap[hash] = sectionScrollHandler;\n            ((_a = sectionScrollHandler.container) === null || _a === void 0 ? void 0 : _a.parentElement).setAttribute('data-react-scroller', hash);\n        }\n        return sectionScrollHandler;\n    }\n}\nexport const scrollManager = new ScrollManager();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}