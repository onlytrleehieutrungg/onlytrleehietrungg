{"ast":null,"code":"import _classCallCheck from \"/Users/trungtran/Documents/GitHub/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trungtran/Documents/GitHub/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport SectionScrollHandler from './SectionScrollHandler';\nvar ScrollStack = /*#__PURE__*/function () {\n  function ScrollStack(scrollHandlerHash) {\n    _classCallCheck(this, ScrollStack);\n    this.stack = [];\n    if (scrollHandlerHash) {\n      this.stack.push(scrollHandlerHash);\n    }\n  }\n  _createClass(ScrollStack, [{\n    key: \"push\",\n    value: function push(scrollHandlerHash) {\n      this.stack.push(scrollHandlerHash);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.stack.pop();\n    }\n  }, {\n    key: \"item\",\n    value: function item(i) {\n      return Object.assign({}, this.stack[i]);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.stack.length;\n    }\n  }, {\n    key: \"current\",\n    get: function get() {\n      return this.stack[this.length - 1];\n    }\n  }, {\n    key: \"previous\",\n    get: function get() {\n      return this.stack[this.length - 2];\n    }\n  }]);\n  return ScrollStack;\n}();\nvar ScrollControl = /*#__PURE__*/function () {\n  function ScrollControl(scrollManager) {\n    _classCallCheck(this, ScrollControl);\n    this.scrollManager = scrollManager;\n  }\n  _createClass(ScrollControl, [{\n    key: \"scrollTo\",\n    value: function scrollTo(target) {\n      this.scrollManager.activeScrollHandler.scrollTo(target);\n    }\n  }, {\n    key: \"scrollToNext\",\n    value: function scrollToNext() {\n      var _this$scrollManager$a = this.scrollManager.activeScrollHandler.UIScrollStateCopy,\n        currentChildIndex = _this$scrollManager$a.currentChildIndex,\n        childs = _this$scrollManager$a.childs;\n      var nextTargetIndex = Math.min(currentChildIndex + 1, childs.length - 1);\n      this.scrollTo(nextTargetIndex);\n    }\n  }, {\n    key: \"scrollToPrevious\",\n    value: function scrollToPrevious() {\n      var currentChildIndex = this.scrollManager.activeScrollHandler.UIScrollStateCopy.currentChildIndex;\n      var nextTargetIndex = Math.max(currentChildIndex - 1, 0);\n      this.scrollTo(nextTargetIndex);\n    }\n  }]);\n  return ScrollControl;\n}();\nexport var ScrollManager = /*#__PURE__*/function () {\n  function ScrollManager() {\n    _classCallCheck(this, ScrollManager);\n    this.scrollStack = new ScrollStack();\n    this.scrollHandlersMap = {};\n    this.scrollControl = new ScrollControl(this);\n  }\n  _createClass(ScrollManager, [{\n    key: \"getScrollMove\",\n    value: function getScrollMove(scrollState) {\n      var XDirection = scrollState.XDirection,\n        YDirection = scrollState.YDirection;\n      if (YDirection !== 'stationary') {\n        return YDirection;\n      }\n      if (XDirection !== 'stationary') {\n        return XDirection;\n      }\n      return null;\n    }\n  }, {\n    key: \"hasReachedEndOfDocument\",\n    value: function hasReachedEndOfDocument(currentChildIndex, childs, scrollState) {\n      var scrollMove = this.getScrollMove(scrollState) || '';\n      var reachedEndOfDocument = ['down', 'left'].includes(scrollMove) && currentChildIndex === childs.length - 1;\n      var reachedStartOfDocument = ['up', 'right'].includes(scrollMove) && !currentChildIndex;\n      var reachedDocumentStartOrEnd = reachedEndOfDocument || reachedStartOfDocument;\n      if (this.scrollStack.previous) {\n        var currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n        var parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n        return currentScrollDirection === parentScrollDirection && reachedDocumentStartOrEnd;\n      }\n      return reachedDocumentStartOrEnd;\n    }\n  }, {\n    key: \"shouldParentResumeScrolling\",\n    value: function shouldParentResumeScrolling(scrollState) {\n      var scrollMove = this.getScrollMove(scrollState) || '';\n      var currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n      var parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n      if (currentScrollDirection !== parentScrollDirection) {\n        if (parentScrollDirection === 'horizontal' && ['left', 'right'].includes(scrollMove)) {\n          return true;\n        }\n        if (parentScrollDirection === 'vertical' && ['up', 'down'].includes(scrollMove)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"transferControlToChild\",\n    value: function transferControlToChild(childNodeHash) {\n      var _a;\n      var currentScrollHandlerHash = (_a = this.scrollStack.current) === null || _a === void 0 ? void 0 : _a.hash;\n      var currentScrollHandler = this.scrollHandlersMap[currentScrollHandlerHash];\n      var _currentScrollHandler = currentScrollHandler.UIScrollStateCopy,\n        currentChildIndex = _currentScrollHandler.currentChildIndex,\n        childs = _currentScrollHandler.childs,\n        scrollState = _currentScrollHandler.scrollState;\n      currentScrollHandler.disable();\n      this.scrollStack.current.scrollState = {\n        reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n        direction: this.getScrollMove(scrollState)\n      };\n      var childScrollHandler = this.scrollHandlersMap[childNodeHash];\n      this.initializeScrollHandler(childScrollHandler);\n      this.scrollStack.push({\n        hash: childNodeHash,\n        scrollState: {\n          reachedEndOfDocument: false,\n          direction: null\n        }\n      });\n      return true;\n    }\n  }, {\n    key: \"transferControlToParent\",\n    value: function transferControlToParent(scrollState) {\n      var _a;\n      for (var i = this.scrollStack.length - 2; i >= 0; i--) {\n        var _this$scrollStack$ite = this.scrollStack.item(i),\n          _this$scrollStack$ite2 = _this$scrollStack$ite.scrollState,\n          reachedEndOfDocument = _this$scrollStack$ite2.reachedEndOfDocument,\n          direction = _this$scrollStack$ite2.direction,\n          hash = _this$scrollStack$ite.hash;\n        var nextScrollDirection = this.getScrollMove(scrollState);\n        if (!(reachedEndOfDocument && direction === nextScrollDirection)) {\n          var currentHash = '';\n          for (var j = this.scrollStack.length - 1; j > i; j--) {\n            currentHash = ((_a = this.scrollStack.pop()) === null || _a === void 0 ? void 0 : _a.hash) || '';\n            this.scrollHandlersMap[currentHash].disable();\n          }\n          var _this$scrollHandlersM = this.scrollHandlersMap[currentHash].UIScrollStateCopy,\n            onScrollCommandCede = _this$scrollHandlersM.onScrollCommandCede,\n            pagesContainer = _this$scrollHandlersM.pagesContainer,\n            currentChildIndex = _this$scrollHandlersM.currentChildIndex;\n          if (pagesContainer.parentElement && onScrollCommandCede) {\n            onScrollCommandCede({\n              lastChildIndex: currentChildIndex\n            });\n          }\n          this.initializeScrollHandler(this.scrollHandlersMap[hash]);\n          return true;\n        }\n      }\n      return false; //this was added\n    }\n  }, {\n    key: \"initializeScrollHandler\",\n    value: function initializeScrollHandler(sectionScrollHandler) {\n      sectionScrollHandler.init(this.scrollControl);\n    }\n  }, {\n    key: \"activeScrollHandler\",\n    get: function get() {\n      return this.scrollHandlersMap[this.scrollStack.current.hash];\n    }\n  }, {\n    key: \"shouldCedeControlToChld\",\n    value: function shouldCedeControlToChld(_ref) {\n      var childs = _ref.childs,\n        currentChildIndex = _ref.currentChildIndex;\n      var currentNodeHash = childs[currentChildIndex].dataset.reactScroller;\n      if (currentNodeHash) {\n        return this.transferControlToChild(currentNodeHash);\n      }\n      return false;\n    }\n  }, {\n    key: \"shouldCedeControlToParent\",\n    value: function shouldCedeControlToParent(_ref2) {\n      var childs = _ref2.childs,\n        currentChildIndex = _ref2.currentChildIndex,\n        scrollState = _ref2.scrollState;\n      if (this.shouldParentResumeScrolling(scrollState) || this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState)) {\n        return this.transferControlToParent(scrollState);\n      }\n      return false;\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(container, scrollUIState) {\n      var _a;\n      var sectionScrollHandler = new SectionScrollHandler(container, scrollUIState, this);\n      var currentChildIndex = scrollUIState.currentChildIndex,\n        childs = scrollUIState.childs,\n        scrollState = scrollUIState.scrollState,\n        isRoot = scrollUIState.isRoot;\n      if (isRoot) {\n        this.scrollHandlersMap.root = sectionScrollHandler;\n        this.scrollStack.push({\n          hash: 'root',\n          scrollState: {\n            reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n            direction: this.getScrollMove(scrollState)\n          }\n        });\n        this.initializeScrollHandler(sectionScrollHandler);\n      } else {\n        var hash = 'nested-' + (Object.keys(this.scrollHandlersMap).length + 1);\n        this.scrollHandlersMap[hash] = sectionScrollHandler;\n        ((_a = sectionScrollHandler.container) === null || _a === void 0 ? void 0 : _a.parentElement).setAttribute('data-react-scroller', hash);\n      }\n      return sectionScrollHandler;\n    }\n  }]);\n  return ScrollManager;\n}();\nexport var scrollManager = new ScrollManager();","map":{"version":3,"names":["SectionScrollHandler","ScrollStack","scrollHandlerHash","_classCallCheck","stack","push","_createClass","key","value","pop","item","i","Object","assign","get","length","ScrollControl","scrollManager","scrollTo","target","activeScrollHandler","scrollToNext","_this$scrollManager$a","UIScrollStateCopy","currentChildIndex","childs","nextTargetIndex","Math","min","scrollToPrevious","max","ScrollManager","scrollStack","scrollHandlersMap","scrollControl","getScrollMove","scrollState","XDirection","YDirection","hasReachedEndOfDocument","scrollMove","reachedEndOfDocument","includes","reachedStartOfDocument","reachedDocumentStartOrEnd","previous","currentScrollDirection","current","hash","direction","parentScrollDirection","shouldParentResumeScrolling","transferControlToChild","childNodeHash","_a","currentScrollHandlerHash","currentScrollHandler","_currentScrollHandler","disable","childScrollHandler","initializeScrollHandler","transferControlToParent","_this$scrollStack$ite","_this$scrollStack$ite2","nextScrollDirection","currentHash","j","_this$scrollHandlersM","onScrollCommandCede","pagesContainer","parentElement","lastChildIndex","sectionScrollHandler","init","shouldCedeControlToChld","_ref","currentNodeHash","dataset","reactScroller","shouldCedeControlToParent","_ref2","subscribe","container","scrollUIState","isRoot","root","keys","setAttribute"],"sources":["/Users/trungtran/Documents/GitHub/portfolio/node_modules/react-page-scroll/dist/esm/App/ScrollManager.js"],"sourcesContent":["import SectionScrollHandler from './SectionScrollHandler';\nclass ScrollStack {\n    constructor(scrollHandlerHash) {\n        this.stack = [];\n        if (scrollHandlerHash) {\n            this.stack.push(scrollHandlerHash);\n        }\n    }\n    push(scrollHandlerHash) {\n        this.stack.push(scrollHandlerHash);\n    }\n    pop() {\n        return this.stack.pop();\n    }\n    item(i) {\n        return Object.assign({}, this.stack[i]);\n    }\n    get length() {\n        return this.stack.length;\n    }\n    get current() {\n        return this.stack[this.length - 1];\n    }\n    get previous() {\n        return this.stack[this.length - 2];\n    }\n}\nclass ScrollControl {\n    constructor(scrollManager) {\n        this.scrollManager = scrollManager;\n    }\n    scrollTo(target) {\n        this.scrollManager.activeScrollHandler.scrollTo(target);\n    }\n    scrollToNext() {\n        const { currentChildIndex, childs } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n        const nextTargetIndex = Math.min(currentChildIndex + 1, childs.length - 1);\n        this.scrollTo(nextTargetIndex);\n    }\n    scrollToPrevious() {\n        const { currentChildIndex } = this.scrollManager.activeScrollHandler.UIScrollStateCopy;\n        const nextTargetIndex = Math.max(currentChildIndex - 1, 0);\n        this.scrollTo(nextTargetIndex);\n    }\n}\nexport class ScrollManager {\n    constructor() {\n        this.scrollStack = new ScrollStack();\n        this.scrollHandlersMap = {};\n        this.scrollControl = new ScrollControl(this);\n    }\n    getScrollMove(scrollState) {\n        const { XDirection, YDirection } = scrollState;\n        if (YDirection !== 'stationary') {\n            return YDirection;\n        }\n        if (XDirection !== 'stationary') {\n            return XDirection;\n        }\n        return null;\n    }\n    hasReachedEndOfDocument(currentChildIndex, childs, scrollState) {\n        const scrollMove = this.getScrollMove(scrollState) || '';\n        const reachedEndOfDocument = ['down', 'left'].includes(scrollMove) && currentChildIndex === childs.length - 1;\n        const reachedStartOfDocument = ['up', 'right'].includes(scrollMove) && !currentChildIndex;\n        const reachedDocumentStartOrEnd = reachedEndOfDocument || reachedStartOfDocument;\n        if (this.scrollStack.previous) {\n            const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n            const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n            return currentScrollDirection === parentScrollDirection && reachedDocumentStartOrEnd;\n        }\n        return reachedDocumentStartOrEnd;\n    }\n    shouldParentResumeScrolling(scrollState) {\n        const scrollMove = this.getScrollMove(scrollState) || '';\n        const currentScrollDirection = this.scrollHandlersMap[this.scrollStack.current.hash].UIScrollStateCopy.direction;\n        const parentScrollDirection = this.scrollHandlersMap[this.scrollStack.previous.hash].UIScrollStateCopy.direction;\n        if (currentScrollDirection !== parentScrollDirection) {\n            if (parentScrollDirection === 'horizontal' && ['left', 'right'].includes(scrollMove)) {\n                return true;\n            }\n            if (parentScrollDirection === 'vertical' && ['up', 'down'].includes(scrollMove)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    transferControlToChild(childNodeHash) {\n        var _a;\n        const currentScrollHandlerHash = (_a = this.scrollStack.current) === null || _a === void 0 ? void 0 : _a.hash;\n        const currentScrollHandler = this.scrollHandlersMap[currentScrollHandlerHash];\n        const { currentChildIndex, childs, scrollState } = currentScrollHandler.UIScrollStateCopy;\n        currentScrollHandler.disable();\n        this.scrollStack.current.scrollState = {\n            reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n            direction: this.getScrollMove(scrollState),\n        };\n        const childScrollHandler = this.scrollHandlersMap[childNodeHash];\n        this.initializeScrollHandler(childScrollHandler);\n        this.scrollStack.push({\n            hash: childNodeHash,\n            scrollState: { reachedEndOfDocument: false, direction: null },\n        });\n        return true;\n    }\n    transferControlToParent(scrollState) {\n        var _a;\n        for (let i = this.scrollStack.length - 2; i >= 0; i--) {\n            const { scrollState: { reachedEndOfDocument, direction }, hash, } = this.scrollStack.item(i);\n            const nextScrollDirection = this.getScrollMove(scrollState);\n            if (!(reachedEndOfDocument && direction === nextScrollDirection)) {\n                let currentHash = '';\n                for (let j = this.scrollStack.length - 1; j > i; j--) {\n                    currentHash = ((_a = this.scrollStack.pop()) === null || _a === void 0 ? void 0 : _a.hash) || '';\n                    this.scrollHandlersMap[currentHash].disable();\n                }\n                const { onScrollCommandCede, pagesContainer, currentChildIndex } = this.scrollHandlersMap[currentHash].UIScrollStateCopy;\n                if (pagesContainer.parentElement && onScrollCommandCede) {\n                    onScrollCommandCede({\n                        lastChildIndex: currentChildIndex,\n                    });\n                }\n                this.initializeScrollHandler(this.scrollHandlersMap[hash]);\n                return true;\n            }\n        }\n        return false; //this was added\n    }\n    initializeScrollHandler(sectionScrollHandler) {\n        sectionScrollHandler.init(this.scrollControl);\n    }\n    get activeScrollHandler() {\n        return this.scrollHandlersMap[this.scrollStack.current.hash];\n    }\n    shouldCedeControlToChld({ childs, currentChildIndex }) {\n        const currentNodeHash = childs[currentChildIndex].dataset.reactScroller;\n        if (currentNodeHash) {\n            return this.transferControlToChild(currentNodeHash);\n        }\n        return false;\n    }\n    shouldCedeControlToParent({ childs, currentChildIndex, scrollState }) {\n        if (this.shouldParentResumeScrolling(scrollState) ||\n            this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState)) {\n            return this.transferControlToParent(scrollState);\n        }\n        return false;\n    }\n    subscribe(container, scrollUIState) {\n        var _a;\n        const sectionScrollHandler = new SectionScrollHandler(container, scrollUIState, this);\n        const { currentChildIndex, childs, scrollState, isRoot } = scrollUIState;\n        if (isRoot) {\n            this.scrollHandlersMap.root = sectionScrollHandler;\n            this.scrollStack.push({\n                hash: 'root',\n                scrollState: {\n                    reachedEndOfDocument: this.hasReachedEndOfDocument(currentChildIndex, childs, scrollState),\n                    direction: this.getScrollMove(scrollState),\n                },\n            });\n            this.initializeScrollHandler(sectionScrollHandler);\n        }\n        else {\n            const hash = 'nested-' + (Object.keys(this.scrollHandlersMap).length + 1);\n            this.scrollHandlersMap[hash] = sectionScrollHandler;\n            ((_a = sectionScrollHandler.container) === null || _a === void 0 ? void 0 : _a.parentElement).setAttribute('data-react-scroller', hash);\n        }\n        return sectionScrollHandler;\n    }\n}\nexport const scrollManager = new ScrollManager();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}