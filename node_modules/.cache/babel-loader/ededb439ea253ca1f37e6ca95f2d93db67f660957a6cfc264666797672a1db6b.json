{"ast":null,"code":"import _classCallCheck from \"/Users/trungtran/Documents/GitHub/portfolio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/trungtran/Documents/GitHub/portfolio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DataSetsAttributes, ScrollDirections } from './Scroll.types';\nimport { TouchScrollEvent, WheelScrollEvent } from './ScrollEvent';\nimport UIScrollAnimation from './UIScrollAnimation';\nvar SectionScrollHandler = /*#__PURE__*/function () {\n  function SectionScrollHandler(container, scrollUIState, scrollManager) {\n    _classCallCheck(this, SectionScrollHandler);\n    this.wheelScrollEvent = new WheelScrollEvent();\n    this.touchScrollEvent = new TouchScrollEvent();\n    this.lasHandledEventId = 0;\n    this.skippedFirstTouchs = 0;\n    this.lastTouchMouve = null;\n    this.container = container;\n    this.scrollUIState = scrollUIState;\n    this.scrollManager = scrollManager;\n    this.bindedShouldHandleWheelScroll = this.shouldHandleWheelScrollEvent.bind(this);\n    this.bindedShouldHandleTouchScroll = this.shouldHandleTouchScrollEvent.bind(this);\n    this.bindedHandleResize = this.handleResize.bind(this);\n  }\n  _createClass(SectionScrollHandler, [{\n    key: \"reinitializeScrollState\",\n    value: function reinitializeScrollState() {\n      this.scrollUIState.scrollState = {\n        YDirection: 'stationary',\n        XDirection: 'stationary'\n      };\n      this.lastTouchMouve = null;\n      this.skippedFirstTouchs = 0;\n    }\n  }, {\n    key: \"handleResize\",\n    value: function handleResize() {\n      var nextOffset = 0,\n        offest = 'offsetHeight',\n        animation = 'translateY';\n      if (this.UIScrollStateCopy.direction === ScrollDirections.horizontal) {\n        animation = 'translateX';\n        offest = 'offsetWidth';\n      }\n      for (var i = 0; i < this.UIScrollStateCopy.currentChildIndex; i++) {\n        nextOffset += this.UIScrollStateCopy.childs[i][offest];\n      }\n      this.UIScrollStateCopy.pagesContainer.style.transform = \"\".concat(animation, \"(\").concat(-nextOffset, \"px)\");\n    }\n  }, {\n    key: \"attachScrollListener\",\n    value: function attachScrollListener() {\n      var _a;\n      var container = this.container;\n      if (container) {\n        container.addEventListener('wheel', this.bindedShouldHandleWheelScroll, {\n          passive: false\n        });\n        (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', this.bindedShouldHandleTouchScroll, {\n          passive: false\n        });\n        window.addEventListener('resize', this.bindedHandleResize);\n      }\n    }\n  }, {\n    key: \"removeScrollListener\",\n    value: function removeScrollListener() {\n      var _a;\n      var container = this.container;\n      if (container) {\n        container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n        (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', this.bindedShouldHandleTouchScroll);\n        //window.removeEventListener(\"resize\", this.bindedHandleResize);\n      }\n    }\n  }, {\n    key: \"blockScroll\",\n    value: function blockScroll() {\n      if (this.container) {\n        this.container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n      }\n    }\n  }, {\n    key: \"enableScroll\",\n    value: function enableScroll() {\n      this.attachScrollListener();\n    }\n  }, {\n    key: \"captureOngoingWheelScrollState\",\n    value: function captureOngoingWheelScrollState(wheelEvent) {\n      var YDirection = 'stationary',\n        XDirection = 'stationary';\n      var DeltaY = Math.abs(wheelEvent.deltaY),\n        DeltaX = Math.abs(wheelEvent.deltaX);\n      if (DeltaY > DeltaX) {\n        if (DeltaY > 1) {\n          if (wheelEvent.deltaY > 0) {\n            YDirection = 'down';\n          } else {\n            YDirection = 'up';\n          }\n        }\n      } else {\n        if (DeltaX > 1) {\n          if (wheelEvent.deltaX > 0) {\n            XDirection = 'left';\n          } else {\n            XDirection = 'right';\n          }\n        }\n      }\n      this.scrollUIState.scrollState = {\n        XDirection: XDirection,\n        YDirection: YDirection\n      };\n      return this.scrollUIState.scrollState;\n    }\n  }, {\n    key: \"captureOngoingTouchScrollState\",\n    value: function captureOngoingTouchScrollState(touchEvent) {\n      var _this$scrollUIState = this.scrollUIState,\n        currentChildIndex = _this$scrollUIState.currentChildIndex,\n        childs = _this$scrollUIState.childs;\n      var YDirection = 'stationary',\n        XDirection = 'stationary';\n      //This lines are added to fine tune the behavior on the last page on mobile some times when you scroll down ig goes up because the forst touch events are somewhat unreliable\n      // maybe this can be fine tuned in a better manner\n      // either way the skipp first touched and sensitivity logic is added to acheive vetter predictability\n      var isFirstOrLastChild = currentChildIndex == 0 || currentChildIndex == childs.length - 1;\n      var touchesToSkip = isFirstOrLastChild ? 4 : 1;\n      if (this.skippedFirstTouchs > touchesToSkip) {\n        if (this.lastTouchMouve) {\n          var _touchEvent$changedTo = touchEvent.changedTouches[0],\n            screenY = _touchEvent$changedTo.screenY,\n            screenX = _touchEvent$changedTo.screenX;\n          var YDelta = screenY - this.lastTouchMouve.screenY;\n          var XDelta = screenX - this.lastTouchMouve.screenX;\n          var isvertical = Math.abs(YDelta) > Math.abs(XDelta);\n          var sensitivity = 0;\n          if (isvertical) {\n            if (YDelta > sensitivity) {\n              YDirection = 'up';\n            } else if (YDelta < -sensitivity) {\n              YDirection = 'down';\n            }\n          } else {\n            if (XDelta > sensitivity) {\n              XDirection = 'right';\n            } else if (XDelta < -sensitivity) {\n              XDirection = 'left';\n            }\n          }\n        } else {\n          this.lastTouchMouve = touchEvent.changedTouches[0];\n        }\n      } else {\n        this.skippedFirstTouchs++;\n      }\n      this.scrollUIState.scrollState = {\n        XDirection: XDirection,\n        YDirection: YDirection\n      };\n      return this.scrollUIState.scrollState;\n    }\n  }, {\n    key: \"setNextChild\",\n    value: function setNextChild() {\n      var _this$scrollUIState2 = this.scrollUIState,\n        currentChildIndex = _this$scrollUIState2.currentChildIndex,\n        childs = _this$scrollUIState2.childs,\n        scrollState = _this$scrollUIState2.scrollState;\n      if (this.scrollUIState.direction === ScrollDirections.vertical && scrollState.YDirection !== 'stationary') {\n        if (scrollState.YDirection === 'down') {\n          if (currentChildIndex < childs.length - 1) {\n            this.scrollUIState.currentChildIndex++;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          if (currentChildIndex > 0) {\n            this.scrollUIState.currentChildIndex--;\n            return true;\n          } else {\n            return false;\n          }\n        }\n      }\n      if (this.scrollUIState.direction === ScrollDirections.horizontal && scrollState.XDirection !== 'stationary') {\n        if (scrollState.XDirection === 'left') {\n          if (currentChildIndex < childs.length - 1) {\n            this.scrollUIState.currentChildIndex++;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          if (currentChildIndex > 0) {\n            this.scrollUIState.currentChildIndex--;\n            return true;\n          } else {\n            return false;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"onScrollEnd\",\n    value: function onScrollEnd() {\n      this.lastTouchMouve = null;\n      var scrollTransfered = this.scrollManager.shouldCedeControlToChld(this.scrollUIState);\n      if (!scrollTransfered) {\n        this.reinitializeScrollState();\n        this.enableScroll();\n      } else {\n        this.disable();\n      }\n      var _this$scrollUIState3 = this.scrollUIState,\n        onScrollEnd = _this$scrollUIState3.onScrollEnd,\n        currentChildIndex = _this$scrollUIState3.currentChildIndex;\n      if (onScrollEnd) {\n        onScrollEnd({\n          currentIndex: currentChildIndex\n        });\n      }\n    }\n  }, {\n    key: \"shouldHandleWheelScrollEvent\",\n    value: function shouldHandleWheelScrollEvent(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.captureOngoingWheelScrollState(event);\n      this.wheelScrollEvent.controlOngoingEvent(event, this.scrollUIState.scrollState);\n      if (this.wheelScrollEvent.id > this.lasHandledEventId) {\n        this.lasHandledEventId = this.wheelScrollEvent.id;\n        this.handleScroll();\n      }\n    }\n  }, {\n    key: \"shouldHandleTouchScrollEvent\",\n    value: function shouldHandleTouchScrollEvent(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.captureOngoingTouchScrollState(event);\n      this.touchScrollEvent.controlOngoingEvent();\n      var _this$scrollUIState$s = this.scrollUIState.scrollState,\n        YDirection = _this$scrollUIState$s.YDirection,\n        XDirection = _this$scrollUIState$s.XDirection;\n      var shouldScroll = YDirection !== 'stationary' || XDirection !== 'stationary';\n      if (this.touchScrollEvent.id > this.lasHandledEventId && shouldScroll) {\n        this.lasHandledEventId = this.touchScrollEvent.id; // last handled wheel direction\n        this.handleScroll();\n      }\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll() {\n      this.blockScroll();\n      var shouldScroll = this.setNextChild();\n      if (shouldScroll) {\n        this.scroll();\n      } else {\n        if (!this.UIScrollStateCopy.isRoot && this.scrollManager.shouldCedeControlToParent(this.UIScrollStateCopy)) {\n          this.disable();\n        } else {\n          this.enableScroll();\n        }\n        this.reinitializeScrollState();\n      }\n    }\n  }, {\n    key: \"initializeScroll\",\n    value: function initializeScroll() {\n      if (this.scrollUIState.pagesContainer) {\n        this.scrollUIState.pagesContainer.style.overflow = 'visible';\n      }\n    }\n  }, {\n    key: \"setScrollState\",\n    value: function setScrollState(targetChildIndex) {\n      var currentChildIndex = this.scrollUIState.currentChildIndex,\n        direction = this.scrollUIState.direction;\n      var YDirection = 'stationary',\n        XDirection = 'stationary';\n      var isvertical = direction === 'vertical';\n      if (currentChildIndex > targetChildIndex) {\n        if (isvertical) {\n          YDirection = 'up';\n        } else {\n          XDirection = 'left';\n        }\n      } else {\n        if (isvertical) {\n          YDirection = 'down';\n        } else {\n          XDirection = 'right';\n        }\n      }\n      this.scrollUIState.scrollState = {\n        XDirection: XDirection,\n        YDirection: YDirection\n      };\n      return this.scrollUIState.scrollState;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(target) {\n      this.setScrollState(target);\n      this.scrollUIState.currentChildIndex = target;\n      this.blockScroll();\n      return this.scroll();\n    }\n  }, {\n    key: \"scroll\",\n    value: function scroll() {\n      var _this$scrollUIState4 = this.scrollUIState,\n        onScrollStart = _this$scrollUIState4.onScrollStart,\n        childs = _this$scrollUIState4.childs,\n        currentChildIndex = _this$scrollUIState4.currentChildIndex,\n        animationDuration = _this$scrollUIState4.animationDuration,\n        direction = _this$scrollUIState4.direction,\n        pagesContainer = _this$scrollUIState4.pagesContainer;\n      if (onScrollStart) {\n        onScrollStart({\n          targetIndex: currentChildIndex\n        });\n      }\n      UIScrollAnimation.fireScroll({\n        childs: childs,\n        currentChildIndex: currentChildIndex,\n        animationDuration: animationDuration,\n        direction: direction,\n        pagesContainer: pagesContainer,\n        onScrollEnd: this.onScrollEnd.bind(this)\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init(scrollControl) {\n      var _this$scrollUIState5 = this.scrollUIState,\n        onScrollInit = _this$scrollUIState5.onScrollInit,\n        scrollEnabled = _this$scrollUIState5.scrollEnabled,\n        currentChildIndex = _this$scrollUIState5.currentChildIndex,\n        childs = _this$scrollUIState5.childs;\n      this.initializeScroll();\n      if (scrollEnabled) {\n        this.attachScrollListener();\n      }\n      for (var i = 0; i < childs.length; i++) {\n        childs[i].setAttribute(DataSetsAttributes.reactScrollPage, 'true');\n        childs[i].setAttribute(DataSetsAttributes.reactScrollPageIndex, i.toString());\n      }\n      if (this.container && onScrollInit) {\n        onScrollInit({\n          currentChildIndex: currentChildIndex,\n          numberOfChilds: childs.length,\n          scrollControl: scrollControl\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.removeScrollListener();\n    }\n  }, {\n    key: \"UIScrollStateCopy\",\n    get: function get() {\n      return Object.assign(Object.assign({}, this.scrollUIState), {\n        scrollState: Object.assign({}, this.scrollUIState.scrollState)\n      });\n    }\n  }]);\n  return SectionScrollHandler;\n}();\nexport default SectionScrollHandler;","map":{"version":3,"names":["DataSetsAttributes","ScrollDirections","TouchScrollEvent","WheelScrollEvent","UIScrollAnimation","SectionScrollHandler","container","scrollUIState","scrollManager","_classCallCheck","wheelScrollEvent","touchScrollEvent","lasHandledEventId","skippedFirstTouchs","lastTouchMouve","bindedShouldHandleWheelScroll","shouldHandleWheelScrollEvent","bind","bindedShouldHandleTouchScroll","shouldHandleTouchScrollEvent","bindedHandleResize","handleResize","_createClass","key","value","reinitializeScrollState","scrollState","YDirection","XDirection","nextOffset","offest","animation","UIScrollStateCopy","direction","horizontal","i","currentChildIndex","childs","pagesContainer","style","transform","concat","attachScrollListener","_a","addEventListener","passive","parentElement","window","removeScrollListener","removeEventListener","blockScroll","enableScroll","captureOngoingWheelScrollState","wheelEvent","DeltaY","Math","abs","deltaY","DeltaX","deltaX","captureOngoingTouchScrollState","touchEvent","_this$scrollUIState","isFirstOrLastChild","length","touchesToSkip","_touchEvent$changedTo","changedTouches","screenY","screenX","YDelta","XDelta","isvertical","sensitivity","setNextChild","_this$scrollUIState2","vertical","onScrollEnd","scrollTransfered","shouldCedeControlToChld","disable","_this$scrollUIState3","currentIndex","event","preventDefault","stopPropagation","controlOngoingEvent","id","handleScroll","_this$scrollUIState$s","shouldScroll","scroll","isRoot","shouldCedeControlToParent","initializeScroll","overflow","setScrollState","targetChildIndex","scrollTo","target","_this$scrollUIState4","onScrollStart","animationDuration","targetIndex","fireScroll","init","scrollControl","_this$scrollUIState5","onScrollInit","scrollEnabled","setAttribute","reactScrollPage","reactScrollPageIndex","toString","numberOfChilds","get","Object","assign"],"sources":["/Users/trungtran/Documents/GitHub/portfolio/node_modules/react-page-scroll/dist/esm/App/SectionScrollHandler.js"],"sourcesContent":["import { DataSetsAttributes, ScrollDirections, } from './Scroll.types';\nimport { TouchScrollEvent, WheelScrollEvent } from './ScrollEvent';\nimport UIScrollAnimation from './UIScrollAnimation';\nclass SectionScrollHandler {\n    constructor(container, scrollUIState, scrollManager) {\n        this.wheelScrollEvent = new WheelScrollEvent();\n        this.touchScrollEvent = new TouchScrollEvent();\n        this.lasHandledEventId = 0;\n        this.skippedFirstTouchs = 0;\n        this.lastTouchMouve = null;\n        this.container = container;\n        this.scrollUIState = scrollUIState;\n        this.scrollManager = scrollManager;\n        this.bindedShouldHandleWheelScroll = this.shouldHandleWheelScrollEvent.bind(this);\n        this.bindedShouldHandleTouchScroll = this.shouldHandleTouchScrollEvent.bind(this);\n        this.bindedHandleResize = this.handleResize.bind(this);\n    }\n    reinitializeScrollState() {\n        this.scrollUIState.scrollState = {\n            YDirection: 'stationary',\n            XDirection: 'stationary',\n        };\n        this.lastTouchMouve = null;\n        this.skippedFirstTouchs = 0;\n    }\n    handleResize() {\n        let nextOffset = 0, offest = 'offsetHeight', animation = 'translateY';\n        if (this.UIScrollStateCopy.direction === ScrollDirections.horizontal) {\n            animation = 'translateX';\n            offest = 'offsetWidth';\n        }\n        for (let i = 0; i < this.UIScrollStateCopy.currentChildIndex; i++) {\n            nextOffset += this.UIScrollStateCopy.childs[i][offest];\n        }\n        this.UIScrollStateCopy.pagesContainer.style.transform = `${animation}(${-nextOffset}px)`;\n    }\n    attachScrollListener() {\n        var _a;\n        const container = this.container;\n        if (container) {\n            container.addEventListener('wheel', this.bindedShouldHandleWheelScroll, { passive: false });\n            (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', this.bindedShouldHandleTouchScroll, { passive: false });\n            window.addEventListener('resize', this.bindedHandleResize);\n        }\n    }\n    removeScrollListener() {\n        var _a;\n        const container = this.container;\n        if (container) {\n            container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n            (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', this.bindedShouldHandleTouchScroll);\n            //window.removeEventListener(\"resize\", this.bindedHandleResize);\n        }\n    }\n    blockScroll() {\n        if (this.container) {\n            this.container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n        }\n    }\n    enableScroll() {\n        this.attachScrollListener();\n    }\n    captureOngoingWheelScrollState(wheelEvent) {\n        let YDirection = 'stationary', XDirection = 'stationary';\n        const DeltaY = Math.abs(wheelEvent.deltaY), DeltaX = Math.abs(wheelEvent.deltaX);\n        if (DeltaY > DeltaX) {\n            if (DeltaY > 1) {\n                if (wheelEvent.deltaY > 0) {\n                    YDirection = 'down';\n                }\n                else {\n                    YDirection = 'up';\n                }\n            }\n        }\n        else {\n            if (DeltaX > 1) {\n                if (wheelEvent.deltaX > 0) {\n                    XDirection = 'left';\n                }\n                else {\n                    XDirection = 'right';\n                }\n            }\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    captureOngoingTouchScrollState(touchEvent) {\n        const { currentChildIndex, childs } = this.scrollUIState;\n        let YDirection = 'stationary', XDirection = 'stationary';\n        //This lines are added to fine tune the behavior on the last page on mobile some times when you scroll down ig goes up because the forst touch events are somewhat unreliable\n        // maybe this can be fine tuned in a better manner\n        // either way the skipp first touched and sensitivity logic is added to acheive vetter predictability\n        const isFirstOrLastChild = currentChildIndex == 0 || currentChildIndex == childs.length - 1;\n        const touchesToSkip = isFirstOrLastChild ? 4 : 1;\n        if (this.skippedFirstTouchs > touchesToSkip) {\n            if (this.lastTouchMouve) {\n                const { screenY, screenX } = touchEvent.changedTouches[0];\n                const YDelta = screenY - this.lastTouchMouve.screenY;\n                const XDelta = screenX - this.lastTouchMouve.screenX;\n                const isvertical = Math.abs(YDelta) > Math.abs(XDelta);\n                const sensitivity = 0;\n                if (isvertical) {\n                    if (YDelta > sensitivity) {\n                        YDirection = 'up';\n                    }\n                    else if (YDelta < -sensitivity) {\n                        YDirection = 'down';\n                    }\n                }\n                else {\n                    if (XDelta > sensitivity) {\n                        XDirection = 'right';\n                    }\n                    else if (XDelta < -sensitivity) {\n                        XDirection = 'left';\n                    }\n                }\n            }\n            else {\n                this.lastTouchMouve = touchEvent.changedTouches[0];\n            }\n        }\n        else {\n            this.skippedFirstTouchs++;\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    setNextChild() {\n        const { currentChildIndex, childs, scrollState } = this.scrollUIState;\n        if (this.scrollUIState.direction === ScrollDirections.vertical && scrollState.YDirection !== 'stationary') {\n            if (scrollState.YDirection === 'down') {\n                if (currentChildIndex < childs.length - 1) {\n                    this.scrollUIState.currentChildIndex++;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                if (currentChildIndex > 0) {\n                    this.scrollUIState.currentChildIndex--;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        if (this.scrollUIState.direction === ScrollDirections.horizontal && scrollState.XDirection !== 'stationary') {\n            if (scrollState.XDirection === 'left') {\n                if (currentChildIndex < childs.length - 1) {\n                    this.scrollUIState.currentChildIndex++;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                if (currentChildIndex > 0) {\n                    this.scrollUIState.currentChildIndex--;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n    onScrollEnd() {\n        this.lastTouchMouve = null;\n        const scrollTransfered = this.scrollManager.shouldCedeControlToChld(this.scrollUIState);\n        if (!scrollTransfered) {\n            this.reinitializeScrollState();\n            this.enableScroll();\n        }\n        else {\n            this.disable();\n        }\n        const { onScrollEnd, currentChildIndex } = this.scrollUIState;\n        if (onScrollEnd) {\n            onScrollEnd({\n                currentIndex: currentChildIndex,\n            });\n        }\n    }\n    shouldHandleWheelScrollEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.captureOngoingWheelScrollState(event);\n        this.wheelScrollEvent.controlOngoingEvent(event, this.scrollUIState.scrollState);\n        if (this.wheelScrollEvent.id > this.lasHandledEventId) {\n            this.lasHandledEventId = this.wheelScrollEvent.id;\n            this.handleScroll();\n        }\n    }\n    shouldHandleTouchScrollEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.captureOngoingTouchScrollState(event);\n        this.touchScrollEvent.controlOngoingEvent();\n        const { YDirection, XDirection } = this.scrollUIState.scrollState;\n        const shouldScroll = YDirection !== 'stationary' || XDirection !== 'stationary';\n        if (this.touchScrollEvent.id > this.lasHandledEventId && shouldScroll) {\n            this.lasHandledEventId = this.touchScrollEvent.id; // last handled wheel direction\n            this.handleScroll();\n        }\n    }\n    handleScroll() {\n        this.blockScroll();\n        const shouldScroll = this.setNextChild();\n        if (shouldScroll) {\n            this.scroll();\n        }\n        else {\n            if (!this.UIScrollStateCopy.isRoot && this.scrollManager.shouldCedeControlToParent(this.UIScrollStateCopy)) {\n                this.disable();\n            }\n            else {\n                this.enableScroll();\n            }\n            this.reinitializeScrollState();\n        }\n    }\n    initializeScroll() {\n        if (this.scrollUIState.pagesContainer) {\n            this.scrollUIState.pagesContainer.style.overflow = 'visible';\n        }\n    }\n    setScrollState(targetChildIndex) {\n        const { currentChildIndex } = this.scrollUIState, { direction } = this.scrollUIState;\n        let YDirection = 'stationary', XDirection = 'stationary';\n        const isvertical = direction === 'vertical';\n        if (currentChildIndex > targetChildIndex) {\n            if (isvertical) {\n                YDirection = 'up';\n            }\n            else {\n                XDirection = 'left';\n            }\n        }\n        else {\n            if (isvertical) {\n                YDirection = 'down';\n            }\n            else {\n                XDirection = 'right';\n            }\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    scrollTo(target) {\n        this.setScrollState(target);\n        this.scrollUIState.currentChildIndex = target;\n        this.blockScroll();\n        return this.scroll();\n    }\n    scroll() {\n        const { onScrollStart, childs, currentChildIndex, animationDuration, direction, pagesContainer } = this.scrollUIState;\n        if (onScrollStart) {\n            onScrollStart({\n                targetIndex: currentChildIndex,\n            });\n        }\n        UIScrollAnimation.fireScroll({\n            childs,\n            currentChildIndex,\n            animationDuration,\n            direction,\n            pagesContainer,\n            onScrollEnd: this.onScrollEnd.bind(this),\n        });\n    }\n    init(scrollControl) {\n        const { onScrollInit, scrollEnabled, currentChildIndex, childs } = this.scrollUIState;\n        this.initializeScroll();\n        if (scrollEnabled) {\n            this.attachScrollListener();\n        }\n        for (let i = 0; i < childs.length; i++) {\n            childs[i].setAttribute(DataSetsAttributes.reactScrollPage, 'true');\n            childs[i].setAttribute(DataSetsAttributes.reactScrollPageIndex, i.toString());\n        }\n        if (this.container && onScrollInit) {\n            onScrollInit({\n                currentChildIndex,\n                numberOfChilds: childs.length,\n                scrollControl,\n            });\n        }\n        return this;\n    }\n    disable() {\n        this.removeScrollListener();\n    }\n    get UIScrollStateCopy() {\n        return Object.assign(Object.assign({}, this.scrollUIState), { scrollState: Object.assign({}, this.scrollUIState.scrollState) });\n    }\n}\nexport default SectionScrollHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}