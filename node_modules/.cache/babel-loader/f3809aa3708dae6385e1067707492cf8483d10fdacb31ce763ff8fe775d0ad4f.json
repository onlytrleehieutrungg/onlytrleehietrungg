{"ast":null,"code":"import { DataSetsAttributes, ScrollDirections } from './Scroll.types';\nimport { TouchScrollEvent, WheelScrollEvent } from './ScrollEvent';\nimport UIScrollAnimation from './UIScrollAnimation';\nclass SectionScrollHandler {\n  constructor(container, scrollUIState, scrollManager) {\n    this.wheelScrollEvent = new WheelScrollEvent();\n    this.touchScrollEvent = new TouchScrollEvent();\n    this.lasHandledEventId = 0;\n    this.skippedFirstTouchs = 0;\n    this.lastTouchMouve = null;\n    this.container = container;\n    this.scrollUIState = scrollUIState;\n    this.scrollManager = scrollManager;\n    this.bindedShouldHandleWheelScroll = this.shouldHandleWheelScrollEvent.bind(this);\n    this.bindedShouldHandleTouchScroll = this.shouldHandleTouchScrollEvent.bind(this);\n    this.bindedHandleResize = this.handleResize.bind(this);\n  }\n  reinitializeScrollState() {\n    this.scrollUIState.scrollState = {\n      YDirection: 'stationary',\n      XDirection: 'stationary'\n    };\n    this.lastTouchMouve = null;\n    this.skippedFirstTouchs = 0;\n  }\n  handleResize() {\n    let nextOffset = 0,\n      offest = 'offsetHeight',\n      animation = 'translateY';\n    if (this.UIScrollStateCopy.direction === ScrollDirections.horizontal) {\n      animation = 'translateX';\n      offest = 'offsetWidth';\n    }\n    for (let i = 0; i < this.UIScrollStateCopy.currentChildIndex; i++) {\n      nextOffset += this.UIScrollStateCopy.childs[i][offest];\n    }\n    this.UIScrollStateCopy.pagesContainer.style.transform = `${animation}(${-nextOffset}px)`;\n  }\n  attachScrollListener() {\n    var _a;\n    const container = this.container;\n    if (container) {\n      container.addEventListener('wheel', this.bindedShouldHandleWheelScroll, {\n        passive: false\n      });\n      (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', this.bindedShouldHandleTouchScroll, {\n        passive: false\n      });\n      window.addEventListener('resize', this.bindedHandleResize);\n    }\n  }\n  removeScrollListener() {\n    var _a;\n    const container = this.container;\n    if (container) {\n      container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n      (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', this.bindedShouldHandleTouchScroll);\n      //window.removeEventListener(\"resize\", this.bindedHandleResize);\n    }\n  }\n\n  blockScroll() {\n    if (this.container) {\n      this.container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n    }\n  }\n  enableScroll() {\n    this.attachScrollListener();\n  }\n  captureOngoingWheelScrollState(wheelEvent) {\n    let YDirection = 'stationary',\n      XDirection = 'stationary';\n    const DeltaY = Math.abs(wheelEvent.deltaY),\n      DeltaX = Math.abs(wheelEvent.deltaX);\n    if (DeltaY > DeltaX) {\n      if (DeltaY > 1) {\n        if (wheelEvent.deltaY > 0) {\n          YDirection = 'down';\n        } else {\n          YDirection = 'up';\n        }\n      }\n    } else {\n      if (DeltaX > 1) {\n        if (wheelEvent.deltaX > 0) {\n          XDirection = 'left';\n        } else {\n          XDirection = 'right';\n        }\n      }\n    }\n    this.scrollUIState.scrollState = {\n      XDirection,\n      YDirection\n    };\n    return this.scrollUIState.scrollState;\n  }\n  captureOngoingTouchScrollState(touchEvent) {\n    const {\n      currentChildIndex,\n      childs\n    } = this.scrollUIState;\n    let YDirection = 'stationary',\n      XDirection = 'stationary';\n    //This lines are added to fine tune the behavior on the last page on mobile some times when you scroll down ig goes up because the forst touch events are somewhat unreliable\n    // maybe this can be fine tuned in a better manner\n    // either way the skipp first touched and sensitivity logic is added to acheive vetter predictability\n    const isFirstOrLastChild = currentChildIndex == 0 || currentChildIndex == childs.length - 1;\n    const touchesToSkip = isFirstOrLastChild ? 4 : 1;\n    if (this.skippedFirstTouchs > touchesToSkip) {\n      if (this.lastTouchMouve) {\n        const {\n          screenY,\n          screenX\n        } = touchEvent.changedTouches[0];\n        const YDelta = screenY - this.lastTouchMouve.screenY;\n        const XDelta = screenX - this.lastTouchMouve.screenX;\n        const isvertical = Math.abs(YDelta) > Math.abs(XDelta);\n        const sensitivity = 0;\n        if (isvertical) {\n          if (YDelta > sensitivity) {\n            YDirection = 'up';\n          } else if (YDelta < -sensitivity) {\n            YDirection = 'down';\n          }\n        } else {\n          if (XDelta > sensitivity) {\n            XDirection = 'right';\n          } else if (XDelta < -sensitivity) {\n            XDirection = 'left';\n          }\n        }\n      } else {\n        this.lastTouchMouve = touchEvent.changedTouches[0];\n      }\n    } else {\n      this.skippedFirstTouchs++;\n    }\n    this.scrollUIState.scrollState = {\n      XDirection,\n      YDirection\n    };\n    return this.scrollUIState.scrollState;\n  }\n  setNextChild() {\n    const {\n      currentChildIndex,\n      childs,\n      scrollState\n    } = this.scrollUIState;\n    if (this.scrollUIState.direction === ScrollDirections.vertical && scrollState.YDirection !== 'stationary') {\n      if (scrollState.YDirection === 'down') {\n        if (currentChildIndex < childs.length - 1) {\n          this.scrollUIState.currentChildIndex++;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        if (currentChildIndex > 0) {\n          this.scrollUIState.currentChildIndex--;\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n    if (this.scrollUIState.direction === ScrollDirections.horizontal && scrollState.XDirection !== 'stationary') {\n      if (scrollState.XDirection === 'left') {\n        if (currentChildIndex < childs.length - 1) {\n          this.scrollUIState.currentChildIndex++;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        if (currentChildIndex > 0) {\n          this.scrollUIState.currentChildIndex--;\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }\n    return false;\n  }\n  onScrollEnd() {\n    this.lastTouchMouve = null;\n    const scrollTransfered = this.scrollManager.shouldCedeControlToChld(this.scrollUIState);\n    if (!scrollTransfered) {\n      this.reinitializeScrollState();\n      this.enableScroll();\n    } else {\n      this.disable();\n    }\n    const {\n      onScrollEnd,\n      currentChildIndex\n    } = this.scrollUIState;\n    if (onScrollEnd) {\n      onScrollEnd({\n        currentIndex: currentChildIndex\n      });\n    }\n  }\n  shouldHandleWheelScrollEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.captureOngoingWheelScrollState(event);\n    this.wheelScrollEvent.controlOngoingEvent(event, this.scrollUIState.scrollState);\n    if (this.wheelScrollEvent.id > this.lasHandledEventId) {\n      this.lasHandledEventId = this.wheelScrollEvent.id;\n      this.handleScroll();\n    }\n  }\n  shouldHandleTouchScrollEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    this.captureOngoingTouchScrollState(event);\n    this.touchScrollEvent.controlOngoingEvent();\n    const {\n      YDirection,\n      XDirection\n    } = this.scrollUIState.scrollState;\n    const shouldScroll = YDirection !== 'stationary' || XDirection !== 'stationary';\n    if (this.touchScrollEvent.id > this.lasHandledEventId && shouldScroll) {\n      this.lasHandledEventId = this.touchScrollEvent.id; // last handled wheel direction\n      this.handleScroll();\n    }\n  }\n  handleScroll() {\n    this.blockScroll();\n    const shouldScroll = this.setNextChild();\n    if (shouldScroll) {\n      this.scroll();\n    } else {\n      if (!this.UIScrollStateCopy.isRoot && this.scrollManager.shouldCedeControlToParent(this.UIScrollStateCopy)) {\n        this.disable();\n      } else {\n        this.enableScroll();\n      }\n      this.reinitializeScrollState();\n    }\n  }\n  initializeScroll() {\n    if (this.scrollUIState.pagesContainer) {\n      this.scrollUIState.pagesContainer.style.overflow = 'visible';\n    }\n  }\n  setScrollState(targetChildIndex) {\n    const {\n        currentChildIndex\n      } = this.scrollUIState,\n      {\n        direction\n      } = this.scrollUIState;\n    let YDirection = 'stationary',\n      XDirection = 'stationary';\n    const isvertical = direction === 'vertical';\n    if (currentChildIndex > targetChildIndex) {\n      if (isvertical) {\n        YDirection = 'up';\n      } else {\n        XDirection = 'left';\n      }\n    } else {\n      if (isvertical) {\n        YDirection = 'down';\n      } else {\n        XDirection = 'right';\n      }\n    }\n    this.scrollUIState.scrollState = {\n      XDirection,\n      YDirection\n    };\n    return this.scrollUIState.scrollState;\n  }\n  scrollTo(target) {\n    this.setScrollState(target);\n    this.scrollUIState.currentChildIndex = target;\n    this.blockScroll();\n    return this.scroll();\n  }\n  scroll() {\n    const {\n      onScrollStart,\n      childs,\n      currentChildIndex,\n      animationDuration,\n      direction,\n      pagesContainer\n    } = this.scrollUIState;\n    if (onScrollStart) {\n      onScrollStart({\n        targetIndex: currentChildIndex\n      });\n    }\n    UIScrollAnimation.fireScroll({\n      childs,\n      currentChildIndex,\n      animationDuration,\n      direction,\n      pagesContainer,\n      onScrollEnd: this.onScrollEnd.bind(this)\n    });\n  }\n  init(scrollControl) {\n    const {\n      onScrollInit,\n      scrollEnabled,\n      currentChildIndex,\n      childs\n    } = this.scrollUIState;\n    this.initializeScroll();\n    if (scrollEnabled) {\n      this.attachScrollListener();\n    }\n    for (let i = 0; i < childs.length; i++) {\n      childs[i].setAttribute(DataSetsAttributes.reactScrollPage, 'true');\n      childs[i].setAttribute(DataSetsAttributes.reactScrollPageIndex, i.toString());\n    }\n    if (this.container && onScrollInit) {\n      onScrollInit({\n        currentChildIndex,\n        numberOfChilds: childs.length,\n        scrollControl\n      });\n    }\n    return this;\n  }\n  disable() {\n    this.removeScrollListener();\n  }\n  get UIScrollStateCopy() {\n    return Object.assign(Object.assign({}, this.scrollUIState), {\n      scrollState: Object.assign({}, this.scrollUIState.scrollState)\n    });\n  }\n}\nexport default SectionScrollHandler;","map":{"version":3,"names":["DataSetsAttributes","ScrollDirections","TouchScrollEvent","WheelScrollEvent","UIScrollAnimation","SectionScrollHandler","constructor","container","scrollUIState","scrollManager","wheelScrollEvent","touchScrollEvent","lasHandledEventId","skippedFirstTouchs","lastTouchMouve","bindedShouldHandleWheelScroll","shouldHandleWheelScrollEvent","bind","bindedShouldHandleTouchScroll","shouldHandleTouchScrollEvent","bindedHandleResize","handleResize","reinitializeScrollState","scrollState","YDirection","XDirection","nextOffset","offest","animation","UIScrollStateCopy","direction","horizontal","i","currentChildIndex","childs","pagesContainer","style","transform","attachScrollListener","_a","addEventListener","passive","parentElement","window","removeScrollListener","removeEventListener","blockScroll","enableScroll","captureOngoingWheelScrollState","wheelEvent","DeltaY","Math","abs","deltaY","DeltaX","deltaX","captureOngoingTouchScrollState","touchEvent","isFirstOrLastChild","length","touchesToSkip","screenY","screenX","changedTouches","YDelta","XDelta","isvertical","sensitivity","setNextChild","vertical","onScrollEnd","scrollTransfered","shouldCedeControlToChld","disable","currentIndex","event","preventDefault","stopPropagation","controlOngoingEvent","id","handleScroll","shouldScroll","scroll","isRoot","shouldCedeControlToParent","initializeScroll","overflow","setScrollState","targetChildIndex","scrollTo","target","onScrollStart","animationDuration","targetIndex","fireScroll","init","scrollControl","onScrollInit","scrollEnabled","setAttribute","reactScrollPage","reactScrollPageIndex","toString","numberOfChilds","Object","assign"],"sources":["/Users/trungtran/Documents/GitHub/portfolio/node_modules/react-page-scroll/dist/esm/App/SectionScrollHandler.js"],"sourcesContent":["import { DataSetsAttributes, ScrollDirections, } from './Scroll.types';\nimport { TouchScrollEvent, WheelScrollEvent } from './ScrollEvent';\nimport UIScrollAnimation from './UIScrollAnimation';\nclass SectionScrollHandler {\n    constructor(container, scrollUIState, scrollManager) {\n        this.wheelScrollEvent = new WheelScrollEvent();\n        this.touchScrollEvent = new TouchScrollEvent();\n        this.lasHandledEventId = 0;\n        this.skippedFirstTouchs = 0;\n        this.lastTouchMouve = null;\n        this.container = container;\n        this.scrollUIState = scrollUIState;\n        this.scrollManager = scrollManager;\n        this.bindedShouldHandleWheelScroll = this.shouldHandleWheelScrollEvent.bind(this);\n        this.bindedShouldHandleTouchScroll = this.shouldHandleTouchScrollEvent.bind(this);\n        this.bindedHandleResize = this.handleResize.bind(this);\n    }\n    reinitializeScrollState() {\n        this.scrollUIState.scrollState = {\n            YDirection: 'stationary',\n            XDirection: 'stationary',\n        };\n        this.lastTouchMouve = null;\n        this.skippedFirstTouchs = 0;\n    }\n    handleResize() {\n        let nextOffset = 0, offest = 'offsetHeight', animation = 'translateY';\n        if (this.UIScrollStateCopy.direction === ScrollDirections.horizontal) {\n            animation = 'translateX';\n            offest = 'offsetWidth';\n        }\n        for (let i = 0; i < this.UIScrollStateCopy.currentChildIndex; i++) {\n            nextOffset += this.UIScrollStateCopy.childs[i][offest];\n        }\n        this.UIScrollStateCopy.pagesContainer.style.transform = `${animation}(${-nextOffset}px)`;\n    }\n    attachScrollListener() {\n        var _a;\n        const container = this.container;\n        if (container) {\n            container.addEventListener('wheel', this.bindedShouldHandleWheelScroll, { passive: false });\n            (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.addEventListener('touchmove', this.bindedShouldHandleTouchScroll, { passive: false });\n            window.addEventListener('resize', this.bindedHandleResize);\n        }\n    }\n    removeScrollListener() {\n        var _a;\n        const container = this.container;\n        if (container) {\n            container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n            (_a = container.parentElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('touchmove', this.bindedShouldHandleTouchScroll);\n            //window.removeEventListener(\"resize\", this.bindedHandleResize);\n        }\n    }\n    blockScroll() {\n        if (this.container) {\n            this.container.removeEventListener('wheel', this.bindedShouldHandleWheelScroll);\n        }\n    }\n    enableScroll() {\n        this.attachScrollListener();\n    }\n    captureOngoingWheelScrollState(wheelEvent) {\n        let YDirection = 'stationary', XDirection = 'stationary';\n        const DeltaY = Math.abs(wheelEvent.deltaY), DeltaX = Math.abs(wheelEvent.deltaX);\n        if (DeltaY > DeltaX) {\n            if (DeltaY > 1) {\n                if (wheelEvent.deltaY > 0) {\n                    YDirection = 'down';\n                }\n                else {\n                    YDirection = 'up';\n                }\n            }\n        }\n        else {\n            if (DeltaX > 1) {\n                if (wheelEvent.deltaX > 0) {\n                    XDirection = 'left';\n                }\n                else {\n                    XDirection = 'right';\n                }\n            }\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    captureOngoingTouchScrollState(touchEvent) {\n        const { currentChildIndex, childs } = this.scrollUIState;\n        let YDirection = 'stationary', XDirection = 'stationary';\n        //This lines are added to fine tune the behavior on the last page on mobile some times when you scroll down ig goes up because the forst touch events are somewhat unreliable\n        // maybe this can be fine tuned in a better manner\n        // either way the skipp first touched and sensitivity logic is added to acheive vetter predictability\n        const isFirstOrLastChild = currentChildIndex == 0 || currentChildIndex == childs.length - 1;\n        const touchesToSkip = isFirstOrLastChild ? 4 : 1;\n        if (this.skippedFirstTouchs > touchesToSkip) {\n            if (this.lastTouchMouve) {\n                const { screenY, screenX } = touchEvent.changedTouches[0];\n                const YDelta = screenY - this.lastTouchMouve.screenY;\n                const XDelta = screenX - this.lastTouchMouve.screenX;\n                const isvertical = Math.abs(YDelta) > Math.abs(XDelta);\n                const sensitivity = 0;\n                if (isvertical) {\n                    if (YDelta > sensitivity) {\n                        YDirection = 'up';\n                    }\n                    else if (YDelta < -sensitivity) {\n                        YDirection = 'down';\n                    }\n                }\n                else {\n                    if (XDelta > sensitivity) {\n                        XDirection = 'right';\n                    }\n                    else if (XDelta < -sensitivity) {\n                        XDirection = 'left';\n                    }\n                }\n            }\n            else {\n                this.lastTouchMouve = touchEvent.changedTouches[0];\n            }\n        }\n        else {\n            this.skippedFirstTouchs++;\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    setNextChild() {\n        const { currentChildIndex, childs, scrollState } = this.scrollUIState;\n        if (this.scrollUIState.direction === ScrollDirections.vertical && scrollState.YDirection !== 'stationary') {\n            if (scrollState.YDirection === 'down') {\n                if (currentChildIndex < childs.length - 1) {\n                    this.scrollUIState.currentChildIndex++;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                if (currentChildIndex > 0) {\n                    this.scrollUIState.currentChildIndex--;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        if (this.scrollUIState.direction === ScrollDirections.horizontal && scrollState.XDirection !== 'stationary') {\n            if (scrollState.XDirection === 'left') {\n                if (currentChildIndex < childs.length - 1) {\n                    this.scrollUIState.currentChildIndex++;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                if (currentChildIndex > 0) {\n                    this.scrollUIState.currentChildIndex--;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n    onScrollEnd() {\n        this.lastTouchMouve = null;\n        const scrollTransfered = this.scrollManager.shouldCedeControlToChld(this.scrollUIState);\n        if (!scrollTransfered) {\n            this.reinitializeScrollState();\n            this.enableScroll();\n        }\n        else {\n            this.disable();\n        }\n        const { onScrollEnd, currentChildIndex } = this.scrollUIState;\n        if (onScrollEnd) {\n            onScrollEnd({\n                currentIndex: currentChildIndex,\n            });\n        }\n    }\n    shouldHandleWheelScrollEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.captureOngoingWheelScrollState(event);\n        this.wheelScrollEvent.controlOngoingEvent(event, this.scrollUIState.scrollState);\n        if (this.wheelScrollEvent.id > this.lasHandledEventId) {\n            this.lasHandledEventId = this.wheelScrollEvent.id;\n            this.handleScroll();\n        }\n    }\n    shouldHandleTouchScrollEvent(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.captureOngoingTouchScrollState(event);\n        this.touchScrollEvent.controlOngoingEvent();\n        const { YDirection, XDirection } = this.scrollUIState.scrollState;\n        const shouldScroll = YDirection !== 'stationary' || XDirection !== 'stationary';\n        if (this.touchScrollEvent.id > this.lasHandledEventId && shouldScroll) {\n            this.lasHandledEventId = this.touchScrollEvent.id; // last handled wheel direction\n            this.handleScroll();\n        }\n    }\n    handleScroll() {\n        this.blockScroll();\n        const shouldScroll = this.setNextChild();\n        if (shouldScroll) {\n            this.scroll();\n        }\n        else {\n            if (!this.UIScrollStateCopy.isRoot && this.scrollManager.shouldCedeControlToParent(this.UIScrollStateCopy)) {\n                this.disable();\n            }\n            else {\n                this.enableScroll();\n            }\n            this.reinitializeScrollState();\n        }\n    }\n    initializeScroll() {\n        if (this.scrollUIState.pagesContainer) {\n            this.scrollUIState.pagesContainer.style.overflow = 'visible';\n        }\n    }\n    setScrollState(targetChildIndex) {\n        const { currentChildIndex } = this.scrollUIState, { direction } = this.scrollUIState;\n        let YDirection = 'stationary', XDirection = 'stationary';\n        const isvertical = direction === 'vertical';\n        if (currentChildIndex > targetChildIndex) {\n            if (isvertical) {\n                YDirection = 'up';\n            }\n            else {\n                XDirection = 'left';\n            }\n        }\n        else {\n            if (isvertical) {\n                YDirection = 'down';\n            }\n            else {\n                XDirection = 'right';\n            }\n        }\n        this.scrollUIState.scrollState = {\n            XDirection,\n            YDirection,\n        };\n        return this.scrollUIState.scrollState;\n    }\n    scrollTo(target) {\n        this.setScrollState(target);\n        this.scrollUIState.currentChildIndex = target;\n        this.blockScroll();\n        return this.scroll();\n    }\n    scroll() {\n        const { onScrollStart, childs, currentChildIndex, animationDuration, direction, pagesContainer } = this.scrollUIState;\n        if (onScrollStart) {\n            onScrollStart({\n                targetIndex: currentChildIndex,\n            });\n        }\n        UIScrollAnimation.fireScroll({\n            childs,\n            currentChildIndex,\n            animationDuration,\n            direction,\n            pagesContainer,\n            onScrollEnd: this.onScrollEnd.bind(this),\n        });\n    }\n    init(scrollControl) {\n        const { onScrollInit, scrollEnabled, currentChildIndex, childs } = this.scrollUIState;\n        this.initializeScroll();\n        if (scrollEnabled) {\n            this.attachScrollListener();\n        }\n        for (let i = 0; i < childs.length; i++) {\n            childs[i].setAttribute(DataSetsAttributes.reactScrollPage, 'true');\n            childs[i].setAttribute(DataSetsAttributes.reactScrollPageIndex, i.toString());\n        }\n        if (this.container && onScrollInit) {\n            onScrollInit({\n                currentChildIndex,\n                numberOfChilds: childs.length,\n                scrollControl,\n            });\n        }\n        return this;\n    }\n    disable() {\n        this.removeScrollListener();\n    }\n    get UIScrollStateCopy() {\n        return Object.assign(Object.assign({}, this.scrollUIState), { scrollState: Object.assign({}, this.scrollUIState.scrollState) });\n    }\n}\nexport default SectionScrollHandler;\n"],"mappings":"AAAA,SAASA,kBAAkB,EAAEC,gBAAgB,QAAS,gBAAgB;AACtE,SAASC,gBAAgB,EAAEC,gBAAgB,QAAQ,eAAe;AAClE,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,MAAMC,oBAAoB,CAAC;EACvBC,WAAWA,CAACC,SAAS,EAAEC,aAAa,EAAEC,aAAa,EAAE;IACjD,IAAI,CAACC,gBAAgB,GAAG,IAAIP,gBAAgB,CAAC,CAAC;IAC9C,IAAI,CAACQ,gBAAgB,GAAG,IAAIT,gBAAgB,CAAC,CAAC;IAC9C,IAAI,CAACU,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B,IAAI,CAACC,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACP,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACM,6BAA6B,GAAG,IAAI,CAACC,4BAA4B,CAACC,IAAI,CAAC,IAAI,CAAC;IACjF,IAAI,CAACC,6BAA6B,GAAG,IAAI,CAACC,4BAA4B,CAACF,IAAI,CAAC,IAAI,CAAC;IACjF,IAAI,CAACG,kBAAkB,GAAG,IAAI,CAACC,YAAY,CAACJ,IAAI,CAAC,IAAI,CAAC;EAC1D;EACAK,uBAAuBA,CAAA,EAAG;IACtB,IAAI,CAACd,aAAa,CAACe,WAAW,GAAG;MAC7BC,UAAU,EAAE,YAAY;MACxBC,UAAU,EAAE;IAChB,CAAC;IACD,IAAI,CAACX,cAAc,GAAG,IAAI;IAC1B,IAAI,CAACD,kBAAkB,GAAG,CAAC;EAC/B;EACAQ,YAAYA,CAAA,EAAG;IACX,IAAIK,UAAU,GAAG,CAAC;MAAEC,MAAM,GAAG,cAAc;MAAEC,SAAS,GAAG,YAAY;IACrE,IAAI,IAAI,CAACC,iBAAiB,CAACC,SAAS,KAAK7B,gBAAgB,CAAC8B,UAAU,EAAE;MAClEH,SAAS,GAAG,YAAY;MACxBD,MAAM,GAAG,aAAa;IAC1B;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,iBAAiB,CAACI,iBAAiB,EAAED,CAAC,EAAE,EAAE;MAC/DN,UAAU,IAAI,IAAI,CAACG,iBAAiB,CAACK,MAAM,CAACF,CAAC,CAAC,CAACL,MAAM,CAAC;IAC1D;IACA,IAAI,CAACE,iBAAiB,CAACM,cAAc,CAACC,KAAK,CAACC,SAAS,GAAI,GAAET,SAAU,IAAG,CAACF,UAAW,KAAI;EAC5F;EACAY,oBAAoBA,CAAA,EAAG;IACnB,IAAIC,EAAE;IACN,MAAMhC,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAIA,SAAS,EAAE;MACXA,SAAS,CAACiC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACzB,6BAA6B,EAAE;QAAE0B,OAAO,EAAE;MAAM,CAAC,CAAC;MAC3F,CAACF,EAAE,GAAGhC,SAAS,CAACmC,aAAa,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAACtB,6BAA6B,EAAE;QAAEuB,OAAO,EAAE;MAAM,CAAC,CAAC;MAC5JE,MAAM,CAACH,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAACpB,kBAAkB,CAAC;IAC9D;EACJ;EACAwB,oBAAoBA,CAAA,EAAG;IACnB,IAAIL,EAAE;IACN,MAAMhC,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAIA,SAAS,EAAE;MACXA,SAAS,CAACsC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC9B,6BAA6B,CAAC;MAC1E,CAACwB,EAAE,GAAGhC,SAAS,CAACmC,aAAa,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACM,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC3B,6BAA6B,CAAC;MAC3I;IACJ;EACJ;;EACA4B,WAAWA,CAAA,EAAG;IACV,IAAI,IAAI,CAACvC,SAAS,EAAE;MAChB,IAAI,CAACA,SAAS,CAACsC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC9B,6BAA6B,CAAC;IACnF;EACJ;EACAgC,YAAYA,CAAA,EAAG;IACX,IAAI,CAACT,oBAAoB,CAAC,CAAC;EAC/B;EACAU,8BAA8BA,CAACC,UAAU,EAAE;IACvC,IAAIzB,UAAU,GAAG,YAAY;MAAEC,UAAU,GAAG,YAAY;IACxD,MAAMyB,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACH,UAAU,CAACI,MAAM,CAAC;MAAEC,MAAM,GAAGH,IAAI,CAACC,GAAG,CAACH,UAAU,CAACM,MAAM,CAAC;IAChF,IAAIL,MAAM,GAAGI,MAAM,EAAE;MACjB,IAAIJ,MAAM,GAAG,CAAC,EAAE;QACZ,IAAID,UAAU,CAACI,MAAM,GAAG,CAAC,EAAE;UACvB7B,UAAU,GAAG,MAAM;QACvB,CAAC,MACI;UACDA,UAAU,GAAG,IAAI;QACrB;MACJ;IACJ,CAAC,MACI;MACD,IAAI8B,MAAM,GAAG,CAAC,EAAE;QACZ,IAAIL,UAAU,CAACM,MAAM,GAAG,CAAC,EAAE;UACvB9B,UAAU,GAAG,MAAM;QACvB,CAAC,MACI;UACDA,UAAU,GAAG,OAAO;QACxB;MACJ;IACJ;IACA,IAAI,CAACjB,aAAa,CAACe,WAAW,GAAG;MAC7BE,UAAU;MACVD;IACJ,CAAC;IACD,OAAO,IAAI,CAAChB,aAAa,CAACe,WAAW;EACzC;EACAiC,8BAA8BA,CAACC,UAAU,EAAE;IACvC,MAAM;MAAExB,iBAAiB;MAAEC;IAAO,CAAC,GAAG,IAAI,CAAC1B,aAAa;IACxD,IAAIgB,UAAU,GAAG,YAAY;MAAEC,UAAU,GAAG,YAAY;IACxD;IACA;IACA;IACA,MAAMiC,kBAAkB,GAAGzB,iBAAiB,IAAI,CAAC,IAAIA,iBAAiB,IAAIC,MAAM,CAACyB,MAAM,GAAG,CAAC;IAC3F,MAAMC,aAAa,GAAGF,kBAAkB,GAAG,CAAC,GAAG,CAAC;IAChD,IAAI,IAAI,CAAC7C,kBAAkB,GAAG+C,aAAa,EAAE;MACzC,IAAI,IAAI,CAAC9C,cAAc,EAAE;QACrB,MAAM;UAAE+C,OAAO;UAAEC;QAAQ,CAAC,GAAGL,UAAU,CAACM,cAAc,CAAC,CAAC,CAAC;QACzD,MAAMC,MAAM,GAAGH,OAAO,GAAG,IAAI,CAAC/C,cAAc,CAAC+C,OAAO;QACpD,MAAMI,MAAM,GAAGH,OAAO,GAAG,IAAI,CAAChD,cAAc,CAACgD,OAAO;QACpD,MAAMI,UAAU,GAAGf,IAAI,CAACC,GAAG,CAACY,MAAM,CAAC,GAAGb,IAAI,CAACC,GAAG,CAACa,MAAM,CAAC;QACtD,MAAME,WAAW,GAAG,CAAC;QACrB,IAAID,UAAU,EAAE;UACZ,IAAIF,MAAM,GAAGG,WAAW,EAAE;YACtB3C,UAAU,GAAG,IAAI;UACrB,CAAC,MACI,IAAIwC,MAAM,GAAG,CAACG,WAAW,EAAE;YAC5B3C,UAAU,GAAG,MAAM;UACvB;QACJ,CAAC,MACI;UACD,IAAIyC,MAAM,GAAGE,WAAW,EAAE;YACtB1C,UAAU,GAAG,OAAO;UACxB,CAAC,MACI,IAAIwC,MAAM,GAAG,CAACE,WAAW,EAAE;YAC5B1C,UAAU,GAAG,MAAM;UACvB;QACJ;MACJ,CAAC,MACI;QACD,IAAI,CAACX,cAAc,GAAG2C,UAAU,CAACM,cAAc,CAAC,CAAC,CAAC;MACtD;IACJ,CAAC,MACI;MACD,IAAI,CAAClD,kBAAkB,EAAE;IAC7B;IACA,IAAI,CAACL,aAAa,CAACe,WAAW,GAAG;MAC7BE,UAAU;MACVD;IACJ,CAAC;IACD,OAAO,IAAI,CAAChB,aAAa,CAACe,WAAW;EACzC;EACA6C,YAAYA,CAAA,EAAG;IACX,MAAM;MAAEnC,iBAAiB;MAAEC,MAAM;MAAEX;IAAY,CAAC,GAAG,IAAI,CAACf,aAAa;IACrE,IAAI,IAAI,CAACA,aAAa,CAACsB,SAAS,KAAK7B,gBAAgB,CAACoE,QAAQ,IAAI9C,WAAW,CAACC,UAAU,KAAK,YAAY,EAAE;MACvG,IAAID,WAAW,CAACC,UAAU,KAAK,MAAM,EAAE;QACnC,IAAIS,iBAAiB,GAAGC,MAAM,CAACyB,MAAM,GAAG,CAAC,EAAE;UACvC,IAAI,CAACnD,aAAa,CAACyB,iBAAiB,EAAE;UACtC,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAO,KAAK;QAChB;MACJ,CAAC,MACI;QACD,IAAIA,iBAAiB,GAAG,CAAC,EAAE;UACvB,IAAI,CAACzB,aAAa,CAACyB,iBAAiB,EAAE;UACtC,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,IAAI,IAAI,CAACzB,aAAa,CAACsB,SAAS,KAAK7B,gBAAgB,CAAC8B,UAAU,IAAIR,WAAW,CAACE,UAAU,KAAK,YAAY,EAAE;MACzG,IAAIF,WAAW,CAACE,UAAU,KAAK,MAAM,EAAE;QACnC,IAAIQ,iBAAiB,GAAGC,MAAM,CAACyB,MAAM,GAAG,CAAC,EAAE;UACvC,IAAI,CAACnD,aAAa,CAACyB,iBAAiB,EAAE;UACtC,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAO,KAAK;QAChB;MACJ,CAAC,MACI;QACD,IAAIA,iBAAiB,GAAG,CAAC,EAAE;UACvB,IAAI,CAACzB,aAAa,CAACyB,iBAAiB,EAAE;UACtC,OAAO,IAAI;QACf,CAAC,MACI;UACD,OAAO,KAAK;QAChB;MACJ;IACJ;IACA,OAAO,KAAK;EAChB;EACAqC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACxD,cAAc,GAAG,IAAI;IAC1B,MAAMyD,gBAAgB,GAAG,IAAI,CAAC9D,aAAa,CAAC+D,uBAAuB,CAAC,IAAI,CAAChE,aAAa,CAAC;IACvF,IAAI,CAAC+D,gBAAgB,EAAE;MACnB,IAAI,CAACjD,uBAAuB,CAAC,CAAC;MAC9B,IAAI,CAACyB,YAAY,CAAC,CAAC;IACvB,CAAC,MACI;MACD,IAAI,CAAC0B,OAAO,CAAC,CAAC;IAClB;IACA,MAAM;MAAEH,WAAW;MAAErC;IAAkB,CAAC,GAAG,IAAI,CAACzB,aAAa;IAC7D,IAAI8D,WAAW,EAAE;MACbA,WAAW,CAAC;QACRI,YAAY,EAAEzC;MAClB,CAAC,CAAC;IACN;EACJ;EACAjB,4BAA4BA,CAAC2D,KAAK,EAAE;IAChCA,KAAK,CAACC,cAAc,CAAC,CAAC;IACtBD,KAAK,CAACE,eAAe,CAAC,CAAC;IACvB,IAAI,CAAC7B,8BAA8B,CAAC2B,KAAK,CAAC;IAC1C,IAAI,CAACjE,gBAAgB,CAACoE,mBAAmB,CAACH,KAAK,EAAE,IAAI,CAACnE,aAAa,CAACe,WAAW,CAAC;IAChF,IAAI,IAAI,CAACb,gBAAgB,CAACqE,EAAE,GAAG,IAAI,CAACnE,iBAAiB,EAAE;MACnD,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAACF,gBAAgB,CAACqE,EAAE;MACjD,IAAI,CAACC,YAAY,CAAC,CAAC;IACvB;EACJ;EACA7D,4BAA4BA,CAACwD,KAAK,EAAE;IAChCA,KAAK,CAACC,cAAc,CAAC,CAAC;IACtBD,KAAK,CAACE,eAAe,CAAC,CAAC;IACvB,IAAI,CAACrB,8BAA8B,CAACmB,KAAK,CAAC;IAC1C,IAAI,CAAChE,gBAAgB,CAACmE,mBAAmB,CAAC,CAAC;IAC3C,MAAM;MAAEtD,UAAU;MAAEC;IAAW,CAAC,GAAG,IAAI,CAACjB,aAAa,CAACe,WAAW;IACjE,MAAM0D,YAAY,GAAGzD,UAAU,KAAK,YAAY,IAAIC,UAAU,KAAK,YAAY;IAC/E,IAAI,IAAI,CAACd,gBAAgB,CAACoE,EAAE,GAAG,IAAI,CAACnE,iBAAiB,IAAIqE,YAAY,EAAE;MACnE,IAAI,CAACrE,iBAAiB,GAAG,IAAI,CAACD,gBAAgB,CAACoE,EAAE,CAAC,CAAC;MACnD,IAAI,CAACC,YAAY,CAAC,CAAC;IACvB;EACJ;EACAA,YAAYA,CAAA,EAAG;IACX,IAAI,CAAClC,WAAW,CAAC,CAAC;IAClB,MAAMmC,YAAY,GAAG,IAAI,CAACb,YAAY,CAAC,CAAC;IACxC,IAAIa,YAAY,EAAE;MACd,IAAI,CAACC,MAAM,CAAC,CAAC;IACjB,CAAC,MACI;MACD,IAAI,CAAC,IAAI,CAACrD,iBAAiB,CAACsD,MAAM,IAAI,IAAI,CAAC1E,aAAa,CAAC2E,yBAAyB,CAAC,IAAI,CAACvD,iBAAiB,CAAC,EAAE;QACxG,IAAI,CAAC4C,OAAO,CAAC,CAAC;MAClB,CAAC,MACI;QACD,IAAI,CAAC1B,YAAY,CAAC,CAAC;MACvB;MACA,IAAI,CAACzB,uBAAuB,CAAC,CAAC;IAClC;EACJ;EACA+D,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAAC7E,aAAa,CAAC2B,cAAc,EAAE;MACnC,IAAI,CAAC3B,aAAa,CAAC2B,cAAc,CAACC,KAAK,CAACkD,QAAQ,GAAG,SAAS;IAChE;EACJ;EACAC,cAAcA,CAACC,gBAAgB,EAAE;IAC7B,MAAM;QAAEvD;MAAkB,CAAC,GAAG,IAAI,CAACzB,aAAa;MAAE;QAAEsB;MAAU,CAAC,GAAG,IAAI,CAACtB,aAAa;IACpF,IAAIgB,UAAU,GAAG,YAAY;MAAEC,UAAU,GAAG,YAAY;IACxD,MAAMyC,UAAU,GAAGpC,SAAS,KAAK,UAAU;IAC3C,IAAIG,iBAAiB,GAAGuD,gBAAgB,EAAE;MACtC,IAAItB,UAAU,EAAE;QACZ1C,UAAU,GAAG,IAAI;MACrB,CAAC,MACI;QACDC,UAAU,GAAG,MAAM;MACvB;IACJ,CAAC,MACI;MACD,IAAIyC,UAAU,EAAE;QACZ1C,UAAU,GAAG,MAAM;MACvB,CAAC,MACI;QACDC,UAAU,GAAG,OAAO;MACxB;IACJ;IACA,IAAI,CAACjB,aAAa,CAACe,WAAW,GAAG;MAC7BE,UAAU;MACVD;IACJ,CAAC;IACD,OAAO,IAAI,CAAChB,aAAa,CAACe,WAAW;EACzC;EACAkE,QAAQA,CAACC,MAAM,EAAE;IACb,IAAI,CAACH,cAAc,CAACG,MAAM,CAAC;IAC3B,IAAI,CAAClF,aAAa,CAACyB,iBAAiB,GAAGyD,MAAM;IAC7C,IAAI,CAAC5C,WAAW,CAAC,CAAC;IAClB,OAAO,IAAI,CAACoC,MAAM,CAAC,CAAC;EACxB;EACAA,MAAMA,CAAA,EAAG;IACL,MAAM;MAAES,aAAa;MAAEzD,MAAM;MAAED,iBAAiB;MAAE2D,iBAAiB;MAAE9D,SAAS;MAAEK;IAAe,CAAC,GAAG,IAAI,CAAC3B,aAAa;IACrH,IAAImF,aAAa,EAAE;MACfA,aAAa,CAAC;QACVE,WAAW,EAAE5D;MACjB,CAAC,CAAC;IACN;IACA7B,iBAAiB,CAAC0F,UAAU,CAAC;MACzB5D,MAAM;MACND,iBAAiB;MACjB2D,iBAAiB;MACjB9D,SAAS;MACTK,cAAc;MACdmC,WAAW,EAAE,IAAI,CAACA,WAAW,CAACrD,IAAI,CAAC,IAAI;IAC3C,CAAC,CAAC;EACN;EACA8E,IAAIA,CAACC,aAAa,EAAE;IAChB,MAAM;MAAEC,YAAY;MAAEC,aAAa;MAAEjE,iBAAiB;MAAEC;IAAO,CAAC,GAAG,IAAI,CAAC1B,aAAa;IACrF,IAAI,CAAC6E,gBAAgB,CAAC,CAAC;IACvB,IAAIa,aAAa,EAAE;MACf,IAAI,CAAC5D,oBAAoB,CAAC,CAAC;IAC/B;IACA,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,MAAM,CAACyB,MAAM,EAAE3B,CAAC,EAAE,EAAE;MACpCE,MAAM,CAACF,CAAC,CAAC,CAACmE,YAAY,CAACnG,kBAAkB,CAACoG,eAAe,EAAE,MAAM,CAAC;MAClElE,MAAM,CAACF,CAAC,CAAC,CAACmE,YAAY,CAACnG,kBAAkB,CAACqG,oBAAoB,EAAErE,CAAC,CAACsE,QAAQ,CAAC,CAAC,CAAC;IACjF;IACA,IAAI,IAAI,CAAC/F,SAAS,IAAI0F,YAAY,EAAE;MAChCA,YAAY,CAAC;QACThE,iBAAiB;QACjBsE,cAAc,EAAErE,MAAM,CAACyB,MAAM;QAC7BqC;MACJ,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACf;EACAvB,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC7B,oBAAoB,CAAC,CAAC;EAC/B;EACA,IAAIf,iBAAiBA,CAAA,EAAG;IACpB,OAAO2E,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACjG,aAAa,CAAC,EAAE;MAAEe,WAAW,EAAEiF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACjG,aAAa,CAACe,WAAW;IAAE,CAAC,CAAC;EACnI;AACJ;AACA,eAAelB,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}